#!/usr/bin/env ruby
# frozen_string_literal: true

# Apple II HDL Terminal Emulator
# Runs the Apple2 HDL component with cycle-accurate simulation

require 'optparse'

$LOAD_PATH.unshift File.expand_path('../../../lib', __dir__)
$LOAD_PATH.unshift File.expand_path('../utilities', __dir__)

require 'rhdl'
require_relative '../utilities/tasks/run_task'
require_relative '../utilities/tasks/demo_program'

# Parse options
options = {
  speed: nil,  # nil means auto-detect based on backend
  debug: false,
  green: false,
  demo: false,
  hires: false,
  hires_width: nil,  # Auto-calculated based on mode and terminal size
  color: false,  # NTSC artifact color rendering
  audio: false,  # Audio output disabled by default
  mode: :hdl,  # Simulation mode: :hdl (default), :netlist
  sim: :ruby   # Simulator backend: :ruby (default), :interpret, :jit, :compile
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: bin/apple2 [options] [program.bin]"
  opts.separator ""
  opts.separator "Apple II HDL Terminal Emulator - Cycle-accurate simulation"
  opts.separator ""

  opts.on("-r", "--rom FILE", "Load ROM file") do |v|
    options[:rom] = v
  end

  opts.on("-a", "--address ADDR", "Load address (hex, default: 0800)") do |v|
    options[:load_addr] = v.to_i(16)
  end

  opts.on("-s", "--speed CYCLES", Integer, "Cycles per frame (auto: 33333 for jit/compile, 10000 for interpret, 100 for ruby)") do |v|
    options[:speed] = v
  end

  opts.on("-d", "--debug", "Show CPU state") do
    options[:debug] = true
  end

  opts.on("-g", "--green", "Green phosphor effect") do
    options[:green] = true
  end

  opts.on("-A", "--audio", "Enable speaker audio output") do
    options[:audio] = true
  end

  opts.on("-m", "--mode TYPE", [:hdl, :netlist, :verilog], "Simulation mode: hdl (default), netlist (gate-level), verilog (Verilator)") do |v|
    options[:mode] = v
  end

  opts.on("--sim TYPE", [:ruby, :interpret, :jit, :compile], "Simulator backend: ruby (default), interpret, jit, compile") do |v|
    options[:sim] = v
  end

  opts.on("--sub-cycles N", Integer, "Sub-cycles per CPU cycle: 14=full, 7=~2x, 2=~7x (compile only)") do |v|
    options[:sub_cycles] = v
  end

  opts.on("-H", "--hires", "Enable hi-res graphics rendering (braille)") do
    options[:hires] = true
  end

  opts.on("-C", "--color", "Enable NTSC artifact color rendering (implies --hires)") do
    options[:color] = true
    options[:hires] = true
  end

  opts.on("--hires-width WIDTH", Integer, "Hi-res display width in chars (auto-adjusts to terminal)") do |v|
    options[:hires_width] = v
  end

  opts.on("--demo", "Run built-in demo") do
    options[:demo] = true
  end

  opts.on("--appleiigo", "Load AppleIIGo ROM") do
    options[:appleiigo] = true
  end

  opts.on("--memdump FILE", "Load memory dump at $0000") do |v|
    options[:memdump] = v
  end

  opts.on("--pc ADDR", "Set initial PC (hex)") do |v|
    options[:pc] = v.to_i(16)
  end

  opts.on("--karateka", "Load Karateka memory dump (enables color mode)") do
    options[:karateka] = true
    options[:hires] = true   # Karateka uses hi-res graphics
    options[:color] = true   # Enable NTSC artifact colors
  end

  opts.on("--disk FILE", "Load disk image (.dsk)") do |v|
    options[:disk] = v
  end

  opts.on("-h", "--help", "Show help") do
    puts opts
    exit
  end
end

parser.parse!(ARGV)

# Auto-adjust speed based on backend if user didn't explicitly set --speed
# Apple II runs at ~1MHz. At 30fps, real-time needs ~33,333 cycles/frame.
if options[:speed].nil?
  options[:speed] = case options[:sim]
                    when :compile, :jit
                      # Compiler and JIT are fast enough for real-time
                      33_333
                    when :interpret
                      # Interpreter is slower, but still faster than Ruby
                      10_000
                    else
                      # Ruby HDL is slow, use conservative default
                      100
                    end
end

terminal = RHDL::Examples::Apple2::Tasks::RunTask.new(options)

# Load AppleIIGo ROM if requested
if options[:appleiigo] || options[:disk]
  rom_file = terminal.software_path('roms/appleiigo.rom')
  if File.exist?(rom_file)
    terminal.load_rom(rom_file, base_addr: 0xD000)
  else
    puts "Error: AppleIIGo ROM not found: #{rom_file}"
    puts "Download from: https://a2go.applearchives.com/roms/"
    exit 1
  end
elsif options[:rom]
  terminal.load_rom(options[:rom])
end

# Load disk image if specified
if options[:disk]
  disk_file = options[:disk]
  unless File.exist?(disk_file)
    puts "Error: Disk image not found: #{disk_file}"
    exit 1
  end
  terminal.load_disk(disk_file)
end

# Load Karateka memory dump if requested
if options[:karateka]
  memdump_file = terminal.software_path('disks/karateka_mem.bin')
  if File.exist?(memdump_file)
    puts "Loading Karateka... (hi-res mode enabled)"
    terminal.load_memdump(memdump_file, pc: 0xB82A, use_appleiigo: true)
  else
    puts "Error: Karateka memory dump not found: #{memdump_file}"
    exit 1
  end
# Load memory dump if specified
elsif options[:memdump]
  pc = options[:pc] || 0x0800
  use_appleiigo = options[:appleiigo] || false
  terminal.load_memdump(options[:memdump], pc: pc, use_appleiigo: use_appleiigo)
# Load program
else
  program_file = ARGV.shift
  if program_file
    load_addr = options[:load_addr] || 0x0800
    terminal.load_program(program_file, base_addr: load_addr)
    terminal.setup_reset_vector(load_addr) unless options[:rom] || options[:appleiigo]
  elsif options[:demo]
    puts "Loading demo program..."
    demo = RHDL::Examples::Apple2::Tasks::DemoProgram.create
    terminal.load_program_bytes(demo, base_addr: 0x0800)
    terminal.setup_reset_vector(0x0800)
  elsif !options[:rom] && !options[:appleiigo]
    puts parser
    puts ""
    puts "Error: No program specified. Use --demo or provide a binary file."
    exit 1
  end
end

terminal.run
