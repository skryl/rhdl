#!/usr/bin/env ruby
# frozen_string_literal: true

# Game Boy HDL Terminal Emulator
# Runs the Game Boy HDL component with cycle-accurate simulation

require 'optparse'

$LOAD_PATH.unshift File.expand_path('../../..', __dir__)
$LOAD_PATH.unshift File.expand_path('../utilities/tasks', __dir__)

require 'rhdl'
require 'run_task'

# Parse command line options
options = {
  speed: 100,
  debug: false,
  dmg_colors: true,
  demo: false,
  pop: false,
  audio: false,
  mode: :ruby,
  sim: nil,
  renderer: :color,
  headless: false
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: bin/gb [options] [rom.gb]"
  opts.separator ""
  opts.separator "Game Boy HDL Terminal Emulator - Cycle-accurate simulation"
  opts.separator ""

  opts.on("-m", "--mode TYPE", [:ruby, :ir, :verilog], "Simulation mode: ruby (default), ir, verilog (Verilator RTL)") do |v|
    options[:mode] = v
  end

  opts.on("--sim TYPE", [:ruby, :interpret, :jit, :compile], "Simulator backend: ruby (default), interpret, jit, compile") do |v|
    options[:sim] = v
  end

  opts.on("--color", "Use color renderer (default)") do
    options[:renderer] = :color
  end

  opts.on("--braille", "Use braille renderer") do
    options[:renderer] = :braille
  end

  opts.on("-s", "--speed CYCLES", Integer, "Cycles per frame (default: 100)") do |v|
    options[:speed] = v
  end

  opts.on("-d", "--debug", "Show CPU state") do
    options[:debug] = true
  end

  opts.on("-g", "--green", "DMG green palette (default)") do
    options[:dmg_colors] = true
  end

  opts.on("-A", "--audio", "Enable audio output") do
    options[:audio] = true
  end

  opts.on("--demo", "Run built-in demo") do
    options[:demo] = true
  end

  opts.on("--pop", "Load Prince of Persia ROM") do
    options[:pop] = true
  end

  opts.on("--headless", "Run without terminal UI (for testing)") do
    options[:headless] = true
  end

  opts.on("--cycles N", Integer, "Number of cycles to run in headless mode") do |v|
    options[:cycles] = v
  end

  opts.on("--lcd-width WIDTH", Integer, "LCD display width in chars (default: 80)") do |v|
    options[:lcd_width] = v
  end

  opts.on("-h", "--help", "Show help") do
    puts opts
    exit
  end
end

parser.parse!(ARGV)

# Default backend by selected mode when --sim is not provided.
if options[:sim].nil?
  options[:sim] = case options[:mode]
                  when :ruby then :ruby
                  when :ir then :compile
                  when :verilog then :ruby
                  else :ruby
                  end
end

# Handle ROM file argument
rom_file = ARGV.shift
if rom_file
  unless File.exist?(rom_file)
    puts "Error: ROM file not found: #{rom_file}"
    exit 1
  end
  options[:rom_file] = rom_file
elsif !options[:demo] && !options[:pop]
  puts parser
  puts ""
  puts "Error: No ROM specified. Use --demo, --pop, or provide a ROM file."
  exit 1
end

# Run the emulator using RunTask
task = RHDL::Examples::GameBoy::Tasks::RunTask.new(options)

begin
  result = task.run

  # In headless mode, output the final CPU state
  if options[:headless] && result.is_a?(Hash)
    puts "Final CPU state:"
    puts "  PC: $#{result[:pc].to_s(16).upcase.rjust(4, '0')}"
    puts "  A:  $#{result[:a].to_s(16).upcase.rjust(2, '0')}"
    puts "  Cycles: #{result[:cycles]}"
  end
rescue ArgumentError => e
  puts "Error: #{e.message}"
  exit 1
rescue Interrupt
  puts "\nInterrupted."
  exit 0
end
