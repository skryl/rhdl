#!/usr/bin/env ruby
# frozen_string_literal: true

# Game Boy HDL Terminal Emulator
# Runs the Game Boy HDL component with cycle-accurate simulation

require 'io/console'
require 'optparse'

$LOAD_PATH.unshift File.expand_path('../../../lib', __dir__)
$LOAD_PATH.unshift File.expand_path('../utilities', __dir__)

require 'rhdl'
require 'gameboy_hdl'

# Game Boy Terminal class for HDL simulation
# Supports HDL mode with multiple simulation backends
class GameBoyTerminal
  # Game Boy screen dimensions
  SCREEN_WIDTH = 160
  SCREEN_HEIGHT = 144

  # Braille display dimensions
  LCD_CHARS_WIDE = 80   # braille chars (160 pixels / 2)
  LCD_CHARS_TALL = 36   # braille chars (144 pixels / 4)

  # ANSI escape codes
  ESC = "\e"
  CLEAR_SCREEN = "#{ESC}[2J"
  MOVE_HOME = "#{ESC}[H"
  HIDE_CURSOR = "#{ESC}[?25l"
  SHOW_CURSOR = "#{ESC}[?25h"
  REVERSE_VIDEO = "#{ESC}[7m"
  NORMAL_VIDEO = "#{ESC}[0m"
  GREEN_FG = "#{ESC}[38;2;155;188;15m"
  DARK_GREEN_FG = "#{ESC}[38;2;15;56;15m"
  BLACK_BG = "#{ESC}[40m"
  BOLD = "#{ESC}[1m"

  attr_reader :runner, :running

  def initialize(options = {})
    @options = options
    @sim_mode = options[:mode] || :hdl
    @sim_backend = options[:sim] || :ruby

    # Create runner based on simulation mode and backend
    @runner = case @sim_mode
              when :hdl
                if @sim_backend == :ruby
                  # Pure Ruby HDL simulation
                  RHDL::GameBoy::HdlRunner.new
                else
                  # IR simulation with native backends
                  require 'gameboy_ir'
                  RHDL::GameBoy::IrRunner.new(backend: @sim_backend)
                end
              else
                raise ArgumentError, "Unknown mode: #{@sim_mode}. Use :hdl"
              end

    @sim_type = @runner.simulator_type

    @running = false
    @cycles_per_frame = options[:speed] || 100
    @debug = options[:debug] || false
    @dmg_colors = options[:dmg_colors] || true
    @audio_enabled = options[:audio] || false

    # Terminal size
    @term_rows = 24
    @term_cols = 80
    @pad_top = 0
    @pad_left = 0
    @lcd_width = options[:lcd_width] || LCD_CHARS_WIDE
    update_terminal_size

    # Performance monitoring
    @start_time = nil
    @start_cycles = 0
    @last_cycles = 0
    @last_time = nil
    @current_hz = 0.0
    @frame_count = 0
    @fps = 0.0
    @last_fps_time = nil
    @fps_frame_count = 0

    # Input tracking
    @last_key = nil
    @last_key_time = nil

    # Keyboard mode
    @keyboard_mode = :normal
  end

  def update_terminal_size
    if $stdout.respond_to?(:winsize) && $stdout.tty?
      begin
        rows, cols = $stdout.winsize
        @term_rows = [rows, 20].max
        @term_cols = [cols, 40].max
      rescue Errno::ENOTTY
        # Not a TTY
      end
    end

    # Calculate padding for LCD display
    lcd_height = LCD_CHARS_TALL + (@debug ? 8 : 2)
    @pad_top = [(@term_rows - lcd_height) / 2, 0].max
    @pad_left = [(@term_cols - @lcd_width) / 2, 0].max
  end

  def load_rom(path)
    puts "Loading ROM: #{path}"
    bytes = File.binread(path)
    @runner.load_rom(bytes)

    # Parse ROM header
    parse_rom_header(bytes)
  end

  def parse_rom_header(bytes)
    return if bytes.length < 0x150

    # Title at 0x134-0x143
    title = bytes[0x134, 16].pack('C*').gsub(/\x00.*/, '').strip
    puts "  Title: #{title}"

    # Cartridge type at 0x147
    cart_type = bytes[0x147]
    puts "  Type: #{cart_type_name(cart_type)}"

    # ROM size at 0x148
    rom_size = 32 * (1 << bytes[0x148]) * 1024
    puts "  ROM: #{rom_size / 1024}KB"

    # RAM size at 0x149
    ram_sizes = [0, 2, 8, 32, 128, 64]
    ram_size = ram_sizes[bytes[0x149]] || 0
    puts "  RAM: #{ram_size}KB" if ram_size > 0
  end

  def cart_type_name(type)
    types = {
      0x00 => "ROM Only",
      0x01 => "MBC1",
      0x02 => "MBC1+RAM",
      0x03 => "MBC1+RAM+Battery",
      0x05 => "MBC2",
      0x06 => "MBC2+Battery",
      0x11 => "MBC3",
      0x12 => "MBC3+RAM",
      0x13 => "MBC3+RAM+Battery",
      0x19 => "MBC5",
      0x1A => "MBC5+RAM",
      0x1B => "MBC5+RAM+Battery"
    }
    types[type] || "Unknown (#{type.to_s(16)})"
  end

  def run
    @running = true

    trap('INT') { @running = false }
    trap('TERM') { @running = false }
    trap('WINCH') { update_terminal_size; print CLEAR_SCREEN }

    mode_name = "HDL (cycle-accurate)"
    puts "Starting Game Boy emulator in #{mode_name} mode..."
    puts "Backend: #{@sim_type}"
    if @audio_enabled
      puts "Audio output: #{RHDL::GameBoy::Speaker.available? ? 'enabled' : 'not available'}"
    end
    puts "WARNING: This mode is slow (for verification/testing)"
    puts "Press Ctrl+C to exit"
    sleep 1

    # Start audio if enabled
    @runner.start_audio if @audio_enabled

    @runner.reset

    @start_time = Time.now
    @start_cycles = @runner.cycle_count
    @last_time = @start_time
    @last_cycles = @start_cycles
    @last_fps_time = @start_time
    @fps_frame_count = 0

    begin
      IO.console.raw do
        print CLEAR_SCREEN
        print HIDE_CURSOR
        main_loop
      end
    ensure
      cleanup
    end
  end

  def stop
    @running = false
  end

  private

  def main_loop
    @frame_count = 0

    while @running && !@runner.halted?
      frame_start = Process.clock_gettime(Process::CLOCK_MONOTONIC)

      handle_keyboard_input
      @runner.run_steps(@cycles_per_frame)
      update_performance_metrics

      if @runner.screen_dirty? || @frame_count % 10 == 0
        render_screen
        @runner.clear_screen_dirty
      end

      @frame_count += 1
      @fps_frame_count += 1

      # Sleep to maintain ~30fps display update
      frame_elapsed = Process.clock_gettime(Process::CLOCK_MONOTONIC) - frame_start
      sleep_time = 0.033 - frame_elapsed
      sleep(sleep_time) if sleep_time > 0
    end

    if @runner.halted?
      state = @runner.cpu_state
      halt_row = @pad_top + LCD_CHARS_TALL + (@debug ? 9 : 3)
      print move_cursor(halt_row, @pad_left + 1)
      puts "CPU HALTED at PC=$#{state[:pc].to_s(16).upcase.rjust(4, '0')}"
      print move_cursor(halt_row + 1, @pad_left + 1)
      puts "Press any key to exit..."
      IO.console.getch
    end
  end

  def handle_keyboard_input
    char = IO.console.read_nonblock(1)
    return unless char

    ascii = char.ord

    # Handle special keys
    case ascii
    when 3 # Ctrl+C
      stop
      return
    when 27 # ESC
      handle_escape_sequence
      return
    end

    # In command mode, handle runtime controls
    if @keyboard_mode == :command
      handle_command_key(ascii)
      return
    end

    # Normal mode: map keys to Game Boy buttons
    # A/Z = A button, S/X = B button, Enter = Start, Backspace = Select
    # Arrow keys = D-pad
    case ascii
    when 65, 97, 90, 122  # A or Z - A button
      @runner.inject_key(0)  # Bit 0
    when 83, 115, 88, 120  # S or X - B button
      @runner.inject_key(1)  # Bit 1
    when 13, 10  # Enter - Start
      @runner.inject_key(3)  # Bit 3
    when 127, 8  # Backspace - Select
      @runner.inject_key(2)  # Bit 2
    end

    @last_key = ascii
    @last_key_time = Time.now
  rescue IO::WaitReadable, Errno::EAGAIN
    # No input available
  end

  def handle_escape_sequence
    if IO.select([IO.console], nil, nil, 0.05)
      begin
        seq = IO.console.read_nonblock(2)
        if @keyboard_mode == :command
          case seq
          when '[C'  # Right - increase speed
            @cycles_per_frame += 10
          when '[D'  # Left - decrease speed
            @cycles_per_frame = [@cycles_per_frame - 10, 10].max
          end
        else
          # Arrow keys to D-pad
          case seq
          when '[A'  # Up
            @runner.inject_key(6)
          when '[B'  # Down
            @runner.inject_key(7)
          when '[C'  # Right
            @runner.inject_key(4)
          when '[D'  # Left
            @runner.inject_key(5)
          end
        end
      rescue IO::WaitReadable, Errno::EAGAIN
        handle_esc_key
      end
    else
      handle_esc_key
    end
  end

  def handle_esc_key
    if @debug
      @keyboard_mode = @keyboard_mode == :normal ? :command : :normal
    end
  end

  def handle_command_key(ascii)
    case ascii
    when 67, 99  # C - toggle color mode
      @dmg_colors = !@dmg_colors
      print CLEAR_SCREEN
    end
  end

  def render_screen
    output = String.new

    if @dmg_colors
      output << GREEN_FG
      output << BLACK_BG
    end

    # Render LCD using braille characters
    lcd_output = @runner.render_lcd_braille(chars_wide: @lcd_width, invert: false)
    lcd_lines = lcd_output.split("\n")

    # Render each line with proper centering
    lcd_lines.each_with_index do |line, row|
      output << move_cursor(@pad_top + row + 1, @pad_left + 1)
      output << line
    end

    output << NORMAL_VIDEO if @dmg_colors

    # Debug window
    if @debug
      debug_width = @lcd_width - 2
      debug_row = @pad_top + lcd_lines.length + 2

      state = @runner.cpu_state
      kb_mode = @keyboard_mode == :command ? "CMD" : "NRM"

      # Line 1: Registers
      line1 = format("PC:%04X A:%02X BC:%04X DE:%04X HL:%04X SP:%04X",
                     state[:pc], state[:a], state[:bc] || 0, state[:de] || 0,
                     state[:hl] || 0, state[:sp] || 0)

      # Line 2: Cycles / speed
      line2 = format("Sim:%-10s Cyc:%s %s %.1ffps Spd:%d",
                     @sim_type.to_s, format_cycles(state[:cycles]),
                     format_hz(@current_hz), @fps, @cycles_per_frame)

      # Line 3: Input / mode
      spk = @runner.speaker
      audio_status = @audio_enabled ? (spk.active? ? "PLAY" : spk.status) : "off"
      line3 = format("Key:%-3s | KB:%s | Aud:%s",
                     format_key(@last_key), kb_mode, audio_status)

      # Line 4: Help
      line4 = "ESC:cmd | C:color | Arrows:speed | ZXAS:ABSS"

      line1 = line1.ljust(debug_width)[0, debug_width]
      line2 = line2.ljust(debug_width)[0, debug_width]
      line3 = line3.ljust(debug_width)[0, debug_width]
      line4 = line4.ljust(debug_width)[0, debug_width]

      output << move_cursor(debug_row, @pad_left + 1)
      output << "+" << ("-" * debug_width) << "+"
      output << move_cursor(debug_row + 1, @pad_left + 1)
      output << "|" << line1 << "|"
      output << move_cursor(debug_row + 2, @pad_left + 1)
      output << "|" << line2 << "|"
      output << move_cursor(debug_row + 3, @pad_left + 1)
      output << "|" << line3 << "|"
      output << move_cursor(debug_row + 4, @pad_left + 1)
      output << "|" << line4 << "|"
      output << move_cursor(debug_row + 5, @pad_left + 1)
      output << "+" << ("-" * debug_width) << "+"
    end

    print output
  end

  def format_cycles(cycles)
    if cycles >= 1_000_000
      format("%.1fM", cycles / 1_000_000.0)
    elsif cycles >= 1_000
      format("%.1fK", cycles / 1_000.0)
    else
      cycles.to_s
    end
  end

  def format_hz(hz)
    if hz >= 1_000_000
      format("%.2fMHz", hz / 1_000_000.0)
    elsif hz >= 1_000
      format("%.1fKHz", hz / 1_000.0)
    else
      format("%.0fHz", hz)
    end
  end

  def format_key(ascii)
    return "---" unless ascii
    return "---" if @last_key_time && (Time.now - @last_key_time) > 2.0

    case ascii
    when 0x00..0x1F
      ctrl_char = (ascii + 0x40).chr
      "^#{ctrl_char}"
    when 0x20
      "SPC"
    when 0x7F
      "DEL"
    else
      "'#{ascii.chr}'"
    end
  end

  def update_performance_metrics
    now = Time.now
    current_cycles = @runner.cpu_state[:cycles]

    elapsed = now - @last_time
    if elapsed >= 0.5
      cycles_delta = current_cycles - @last_cycles
      @current_hz = cycles_delta / elapsed
      @last_time = now
      @last_cycles = current_cycles
    end

    fps_elapsed = now - @last_fps_time
    if fps_elapsed >= 1.0
      @fps = @fps_frame_count / fps_elapsed
      @last_fps_time = now
      @fps_frame_count = 0
    end
  end

  def move_cursor(row, col)
    "#{ESC}[#{row};#{col}H"
  end

  def cleanup
    @runner.stop_audio if @audio_enabled

    print SHOW_CURSOR
    print NORMAL_VIDEO
    exit_row = @pad_top + LCD_CHARS_TALL + (@debug ? 11 : 5)
    print move_cursor(exit_row, 1)
    puts "Game Boy HDL emulator terminated."
  end
end

# Demo program - simple test ROM
def create_demo_rom
  # Create a minimal Game Boy ROM that fills the screen
  rom = Array.new(32 * 1024, 0)

  # Nintendo logo at 0x104 (required for boot)
  nintendo_logo = [
    0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
    0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
    0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E
  ]
  nintendo_logo.each_with_index { |b, i| rom[0x104 + i] = b }

  # Title at 0x134
  "RHDL TEST".bytes.each_with_index { |b, i| rom[0x134 + i] = b }

  # Header checksum at 0x14D
  checksum = 0
  (0x134...0x14D).each { |i| checksum = (checksum - rom[i] - 1) & 0xFF }
  rom[0x14D] = checksum

  # Entry point at 0x100 - NOP NOP JP 0x150
  rom[0x100] = 0x00  # NOP
  rom[0x101] = 0x00  # NOP
  rom[0x102] = 0xC3  # JP
  rom[0x103] = 0x50  # addr low
  rom[0x104] = 0x01  # addr high (will be overwritten by logo, but that's ok for demo)

  # Main program at 0x150
  pc = 0x150

  # Turn on LCD
  rom[pc] = 0x3E; pc += 1  # LD A, $91
  rom[pc] = 0x91; pc += 1
  rom[pc] = 0xE0; pc += 1  # LDH ($40), A
  rom[pc] = 0x40; pc += 1

  # Infinite loop
  loop_addr = pc
  rom[pc] = 0x00; pc += 1  # NOP
  rom[pc] = 0x18; pc += 1  # JR loop
  rom[pc] = (loop_addr - pc - 1) & 0xFF; pc += 1

  rom.pack('C*')
end

# Parse options
options = {
  speed: 100,
  debug: false,
  dmg_colors: true,
  demo: false,
  pop: false,
  audio: false,
  mode: :hdl,
  sim: :ruby
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: bin/gb [options] [rom.gb]"
  opts.separator ""
  opts.separator "Game Boy HDL Terminal Emulator - Cycle-accurate simulation"
  opts.separator ""

  opts.on("-m", "--mode TYPE", [:hdl], "Simulation mode: hdl (default)") do |v|
    options[:mode] = v
  end

  opts.on("--sim TYPE", [:ruby, :interpret, :jit, :compile], "Simulator backend: ruby (default), interpret, jit, compile") do |v|
    options[:sim] = v
  end

  opts.on("-s", "--speed CYCLES", Integer, "Cycles per frame (default: 100)") do |v|
    options[:speed] = v
  end

  opts.on("-d", "--debug", "Show CPU state") do
    options[:debug] = true
  end

  opts.on("-g", "--green", "DMG green palette (default)") do
    options[:dmg_colors] = true
  end

  opts.on("-A", "--audio", "Enable audio output") do
    options[:audio] = true
  end

  opts.on("--demo", "Run built-in demo") do
    options[:demo] = true
  end

  opts.on("--pop", "Load Prince of Persia ROM") do
    options[:pop] = true
  end

  opts.on("--lcd-width WIDTH", Integer, "LCD display width in chars (default: 80)") do |v|
    options[:lcd_width] = v
  end

  opts.on("--dry-run", "Output engine info without running") do
    options[:dry_run] = true
  end

  opts.on("-h", "--help", "Show help") do
    puts opts
    exit
  end
end

parser.parse!(ARGV)

terminal = GameBoyTerminal.new(options)

# Load ROM
rom_file = ARGV.shift
if rom_file
  unless File.exist?(rom_file)
    puts "Error: ROM file not found: #{rom_file}"
    exit 1
  end
  terminal.load_rom(rom_file)
elsif options[:pop]
  pop_rom = File.expand_path('../software/roms/pop.gb', __dir__)
  if File.exist?(pop_rom)
    puts "Loading Prince of Persia..."
    terminal.load_rom(pop_rom)
  else
    puts "Error: Prince of Persia ROM not found: #{pop_rom}"
    exit 1
  end
elsif options[:demo]
  puts "Loading demo ROM..."
  demo_rom = create_demo_rom
  terminal.runner.load_rom(demo_rom)
else
  puts parser
  puts ""
  puts "Error: No ROM specified. Use --demo, --pop, or provide a ROM file."
  exit 1
end

# Handle dry-run mode
if options[:dry_run]
  require 'json'
  info = terminal.runner.dry_run_info
  puts JSON.pretty_generate(info)
  exit 0
end

terminal.run
