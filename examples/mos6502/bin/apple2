#!/usr/bin/env ruby
# frozen_string_literal: true

# Apple ][ Terminal Emulator
# Runs a 6502 simulation with Apple II-style memory-mapped I/O

require 'io/console'
require 'optparse'

$LOAD_PATH.unshift File.expand_path('../../../lib', __dir__)
$LOAD_PATH.unshift File.expand_path('../utilities', __dir__)

require 'rhdl'
require 'apple2_harness'
require 'isa_simulator'

# Wrapper for pure Ruby ISA simulator to match ISARunner interface
class RubyISARunner
  attr_reader :cpu, :bus

  def initialize(bus, cpu)
    @bus = bus
    @cpu = cpu
  end

  def native?
    false
  end

  def simulator_type
    :ruby
  end

  def load_rom(bytes, base_addr:)
    @bus.load_rom(bytes.is_a?(String) ? bytes.bytes : bytes, base_addr: base_addr)
  end

  def load_ram(bytes, base_addr:)
    @bus.load_ram(bytes.is_a?(String) ? bytes.bytes : bytes, base_addr: base_addr)
  end

  def load_disk(path_or_bytes, drive: 0)
    @bus.load_disk(path_or_bytes, drive: drive)
  end

  def disk_loaded?(drive: 0)
    @bus.disk_loaded?(drive: drive)
  end

  def reset
    @cpu.reset
  end

  def run_steps(steps)
    @cpu.run_cycles(steps)
  end

  def inject_key(ascii)
    @bus.inject_key(ascii)
  end

  def key_ready?
    @bus.key_ready
  end

  def clear_key
    @bus.clear_key
  end

  def read_screen
    @bus.read_text_page_string
  end

  def read_screen_array
    @bus.read_text_page
  end

  def screen_dirty?
    @bus.text_page_dirty?
  end

  def clear_screen_dirty
    @bus.clear_text_page_dirty
  end

  def cpu_state
    {
      pc: @cpu.pc,
      a: @cpu.a,
      x: @cpu.x,
      y: @cpu.y,
      sp: @cpu.sp,
      p: @cpu.p,
      cycles: @cpu.cycles,
      halted: @cpu.halted?,
      simulator_type: :ruby
    }
  end

  def halted?
    @cpu.halted?
  end

  def cycle_count
    @cpu.cycles
  end
end

# Apple II Terminal class
class Apple2Terminal
  SCREEN_ROWS = 24
  SCREEN_COLS = 40

  # Hi-res display dimensions
  HIRES_WIDTH = 140   # braille chars (280 pixels / 2)
  HIRES_HEIGHT = 48   # braille chars (192 pixels / 4)

  # Display dimensions including border
  DISPLAY_WIDTH = SCREEN_COLS + 2   # 42 (40 + 2 border chars)
  DISPLAY_HEIGHT = SCREEN_ROWS + 2  # 26 (24 + 2 border lines)

  # ANSI escape codes
  ESC = "\e"
  CLEAR_SCREEN = "#{ESC}[2J"
  MOVE_HOME = "#{ESC}[H"
  HIDE_CURSOR = "#{ESC}[?25l"
  SHOW_CURSOR = "#{ESC}[?25h"
  REVERSE_VIDEO = "#{ESC}[7m"
  NORMAL_VIDEO = "#{ESC}[0m"
  GREEN_FG = "#{ESC}[32m"
  BLACK_BG = "#{ESC}[40m"
  BOLD = "#{ESC}[1m"

  attr_reader :runner, :running

  def initialize(options = {})
    @options = options
    @sim_type = options[:mode] || :native

    # Create runner based on simulator type
    @runner = case @sim_type
              when :native
                runner = Apple2Harness::ISARunner.new
                # Verify we got native, warn if fell back to ruby
                unless runner.native?
                  warn "Warning: Native simulator not available, using Ruby ISA simulator"
                  @sim_type = :ruby
                end
                runner
              when :ruby
                # Force Ruby ISA simulator
                bus = MOS6502::Apple2Bus.new("apple2_bus")
                cpu = MOS6502::ISASimulator.new(bus)
                # Wrap in a simple runner-like object
                RubyISARunner.new(bus, cpu)
              when :hdl
                Apple2Harness::Runner.new
              else
                raise "Unknown simulator type: #{@sim_type}"
              end

    @running = false
    @last_screen = nil
    @cycles_per_frame = options[:speed] || 10_000
    @debug = options[:debug] || false
    @green_screen = options[:green] || false
    @hires_mode = options[:hires] || false
    @hires_width = options[:hires_width] || 80
    @audio_enabled = options[:audio] != false

    # Terminal size and padding for centering
    @term_rows = 24
    @term_cols = 80
    @pad_top = 0
    @pad_left = 0
    @hires_pad_top = 0
    @hires_pad_left = 0
    update_terminal_size

    # Performance monitoring
    @start_time = nil
    @start_cycles = 0
    @last_cycles = 0
    @last_time = nil
    @current_hz = 0.0
    @frame_count = 0
    @fps = 0.0
    @last_fps_time = nil
    @fps_frame_count = 0

    # Input tracking for debug
    @last_key = nil
    @last_key_time = nil
  end

  def update_terminal_size
    if $stdout.respond_to?(:winsize)
      rows, cols = $stdout.winsize
      @term_rows = [rows, DISPLAY_HEIGHT].max
      @term_cols = [cols, DISPLAY_WIDTH].max
    end

    # Calculate padding to center the text display
    # Debug mode adds bordered debug window: 1 padding + 6 lines (border + 4 content + border)
    # Non-debug adds 1 for disk loading indicator
    display_height = @debug ? DISPLAY_HEIGHT + 7 : DISPLAY_HEIGHT
    @pad_top = [(@term_rows - display_height) / 2, 0].max
    @pad_left = [(@term_cols - DISPLAY_WIDTH) / 2, 0].max

    # Calculate padding for hires display
    # Hires output is always 48 lines tall (192 pixels / 4 dots per braille char)
    # Width can vary, but height is fixed
    # Debug mode adds bordered debug window: 2 gap + 6 lines (border + 4 content + border)
    # Non-debug adds 1 for disk loading indicator
    hires_content_height = HIRES_HEIGHT  # Always 48 braille chars tall
    debug_panel_height = @debug ? 8 : 1  # 6 lines debug box + 2 gap, or 1 line for disk status
    total_content_height = hires_content_height + debug_panel_height
    hires_display_width = @hires_width

    # If content fits in terminal, center it
    # If content doesn't fit, position so debug panel is visible at bottom (sacrifice top of hires)
    if total_content_height <= @term_rows
      # Content fits - center it
      @hires_pad_top = [(@term_rows - total_content_height) / 2, 0].max
    else
      # Content doesn't fit - ensure debug panel is visible at bottom
      # Calculate pad_top so that the bottom of content aligns with bottom of terminal
      @hires_pad_top = @term_rows - total_content_height
      # Allow negative pad_top - this will push hires content up off screen
      # but keep debug panel visible
    end
    @hires_pad_left = [(@term_cols - hires_display_width) / 2, 0].max
  end

  def load_rom(path, base_addr: 0xF800)
    puts "Loading ROM: #{path} at $#{base_addr.to_s(16).upcase}"
    bytes = File.binread(path)
    @runner.load_rom(bytes, base_addr: base_addr)
  end

  def load_program(path, base_addr: 0x0800)
    puts "Loading program: #{path} at $#{base_addr.to_s(16).upcase}"
    bytes = File.binread(path)
    @runner.load_ram(bytes, base_addr: base_addr)
  end

  def load_program_bytes(bytes, base_addr: 0x0800)
    @runner.load_ram(bytes, base_addr: base_addr)
  end

  def load_disk(path, drive: 0)
    puts "Loading disk: #{path} into drive #{drive + 1}"
    @runner.load_disk(path, drive: drive)
  end

  def setup_reset_vector(addr)
    # Set reset vector to point to our program
    # For native mode, write to CPU memory; otherwise write to bus
    if @sim_type == :native && @runner.respond_to?(:native?) && @runner.native?
      @runner.cpu.poke(0xFFFC, addr & 0xFF)
      @runner.cpu.poke(0xFFFD, (addr >> 8) & 0xFF)
    else
      @runner.bus.write(0xFFFC, addr & 0xFF)
      @runner.bus.write(0xFFFD, (addr >> 8) & 0xFF)
    end
  end

  def run
    @running = true
    @resize_pending = false

    # Set up signal handler for clean exit
    trap('INT') { stop }
    trap('TERM') { stop }

    # Handle terminal resize
    trap('WINCH') do
      @resize_pending = true
    end

    mode_names = { native: "Native ISA", ruby: "Ruby ISA", hdl: "HDL (cycle-accurate)" }
    mode = mode_names[@sim_type] || @sim_type.to_s
    audio_status = @audio_enabled ? "Audio ON" : "Audio OFF"
    puts "Starting Apple ][ emulator... [#{mode} mode, #{audio_status}]"
    puts "Press Ctrl+C to exit"
    puts "Press any key to continue..."
    sleep 0.5

    # Start audio if enabled
    if @audio_enabled
      @runner.bus.start_audio
    end

    # Reset the CPU
    @runner.reset

    # Initialize performance monitoring
    @start_time = Time.now
    @start_cycles = @runner.cpu_state[:cycles]
    @last_time = @start_time
    @last_cycles = @start_cycles
    @last_fps_time = @start_time
    @fps_frame_count = 0

    # Enter raw terminal mode
    begin
      IO.console.raw do
        print CLEAR_SCREEN
        print HIDE_CURSOR

        main_loop
      end
    ensure
      cleanup
    end
  end

  def stop
    @running = false
  end

  private

  def main_loop
    @frame_count = 0

    while @running && !@runner.halted?
      # Handle terminal resize
      if @resize_pending
        @resize_pending = false
        update_terminal_size
        print CLEAR_SCREEN
      end

      # Check for keyboard input (non-blocking)
      handle_keyboard_input

      # Get cycle count before running
      cycles_before = @runner.cycle_count

      # Run CPU cycles
      @runner.run_steps(@cycles_per_frame)

      # Get cycles actually executed and update bus timing
      cycles_after = @runner.cycle_count
      cycles_executed = cycles_after - cycles_before
      @runner.bus.tick(cycles_executed) if cycles_executed > 0

      # Update performance metrics
      update_performance_metrics

      # Update display if screen changed
      if @runner.screen_dirty? || @frame_count % 10 == 0
        render_screen
        @runner.clear_screen_dirty
      end

      @frame_count += 1
      @fps_frame_count += 1

      # Small delay to prevent CPU spinning
      sleep 0.016 # ~60fps
    end

    if @runner.halted?
      # Position halted message below the display (after debug and disk loading lines)
      halt_row = @pad_top + DISPLAY_HEIGHT + (@debug ? 7 : 2)
      print move_cursor(halt_row, @pad_left + 1)
      puts "CPU HALTED at PC=$#{@runner.cpu_state[:pc].to_s(16).upcase.rjust(4, '0')}"
      print move_cursor(halt_row + 1, @pad_left + 1)
      puts "Press any key to exit..."
      IO.console.getch
    end
  end

  def handle_keyboard_input
    # Non-blocking read
    char = IO.console.read_nonblock(1)
    return unless char

    ascii = char.ord

    # Handle special keys
    case ascii
    when 3 # Ctrl+C
      stop
      return
    when 27 # ESC - check for arrow keys
      handle_escape_sequence
      return
    when 127, 8 # Backspace/Delete
      ascii = 0x08 # Apple II backspace
    when 10, 13 # Enter/Return
      ascii = 0x0D # Apple II carriage return
    end

    # Convert lowercase to uppercase for Apple II
    ascii = ascii - 32 if ascii >= 97 && ascii <= 122

    # Track for debug display
    @last_key = ascii
    @last_key_time = Time.now

    # Inject the key
    @runner.inject_key(ascii)
  rescue IO::WaitReadable, Errno::EAGAIN
    # No input available, continue
  end

  def handle_escape_sequence
    # Try to read arrow key sequence
    begin
      seq = IO.console.read_nonblock(2)
      case seq
      when '[A' # Up arrow
        @runner.inject_key(0x0B) # Ctrl+K (up)
      when '[B' # Down arrow
        @runner.inject_key(0x0A) # Ctrl+J (down)
      when '[C' # Right arrow
        @runner.inject_key(0x15) # Ctrl+U (right)
      when '[D' # Left arrow
        @runner.inject_key(0x08) # Ctrl+H (left/backspace)
      end
    rescue IO::WaitReadable, Errno::EAGAIN
      # Just ESC key pressed
      @runner.inject_key(0x1B)
    end
  end

  def render_screen
    # Sync video state from native CPU to bus (for soft switches handled in Rust)
    @runner.sync_video_state if @runner.respond_to?(:sync_video_state)

    # Check if we should render hi-res graphics
    # Automatically switch based on soft switch state, or force with -H flag
    if @runner.bus.hires_mode? || (@hires_mode && !@runner.bus.text_mode?)
      render_hires_screen
    else
      render_text_screen
    end
  end

  def render_hires_screen
    output = String.new

    if @green_screen
      output << GREEN_FG
      output << BLACK_BG
    end

    # Render hi-res using braille characters
    hires_output = @runner.bus.render_hires_braille(chars_wide: @hires_width, invert: true)
    hires_lines = hires_output.split("\n")

    # Render each line of hires output with proper centering
    hires_lines.each_with_index do |line, row|
      output << move_cursor(@hires_pad_top + row + 1, @hires_pad_left + 1)
      output << line
    end

    output << NORMAL_VIDEO if @green_screen

    # Debug window (bordered, with padding above)
    if @debug
      # Debug window width matches hires display width
      debug_width = @hires_width - 2  # Account for border chars

      # Add 1 line padding between hires display and debug window
      debug_row = @hires_pad_top + hires_lines.length + 2

      state = @runner.cpu_state
      dc = @runner.bus.disk_controller
      sim_type = (state[:simulator_type] || 'unknown').to_s.upcase

      # Line 1: Registers
      line1 = format("PC:%04X A:%02X X:%02X Y:%02X SP:%02X P:%02X [HIRES]",
                     state[:pc], state[:a], state[:x], state[:y],
                     state[:sp], state[:p])

      # Line 2: Sim type / cycles / speed / uptime
      line2 = format("Sim:%-6s Cyc:%s %s %.1ffps Up:%s",
                     sim_type, format_cycles(state[:cycles]),
                     format_hz(@current_hz), @fps,
                     format_uptime(@start_time))

      # Line 3: Disk IO / keyboard IO
      line3 = format("Disk:T%02d %s | Key:%-3s",
                     dc.track, dc.motor_on ? "ON " : "OFF",
                     format_key(@last_key))

      # Line 4: Audio status with toggle count and activity
      speaker = @runner.bus.speaker
      audio_status = speaker.status
      activity = speaker.active? ? "*" : " "
      toggle_count = format_number(speaker.toggle_count)
      line4 = format("Audio:%s%s Tgl:%s Smp:%s",
                     audio_status, activity, toggle_count,
                     format_number(speaker.samples_written))

      # Pad/truncate lines to fit within border
      line1 = line1.ljust(debug_width)[0, debug_width]
      line2 = line2.ljust(debug_width)[0, debug_width]
      line3 = line3.ljust(debug_width)[0, debug_width]
      line4 = line4.ljust(debug_width)[0, debug_width]

      # Draw debug window with border (now 4 lines of content)
      output << move_cursor(debug_row, @hires_pad_left + 1)
      output << "+" << ("-" * debug_width) << "+"
      output << move_cursor(debug_row + 1, @hires_pad_left + 1)
      output << "|" << line1 << "|"
      output << move_cursor(debug_row + 2, @hires_pad_left + 1)
      output << "|" << line2 << "|"
      output << move_cursor(debug_row + 3, @hires_pad_left + 1)
      output << "|" << line3 << "|"
      output << move_cursor(debug_row + 4, @hires_pad_left + 1)
      output << "|" << line4 << "|"
      output << move_cursor(debug_row + 5, @hires_pad_left + 1)
      output << "+" << ("-" * debug_width) << "+"
    elsif disk_motor_on?
      status_row = @hires_pad_top + hires_lines.length + 1
      output << move_cursor(status_row, @hires_pad_left + 1)
      output << "DISK LOADING..."
    end

    print output
  end

  def render_text_screen
    output = String.new

    # Move cursor to the top-left corner of the centered display
    # ANSI cursor positions are 1-based
    output << move_cursor(@pad_top + 1, @pad_left + 1)

    if @green_screen
      output << GREEN_FG
      output << BLACK_BG
    end

    # Horizontal padding string (reused for each line)
    h_pad = " " * @pad_left

    # Draw border top
    output << "+" << ("-" * SCREEN_COLS) << "+"
    output << move_cursor(@pad_top + 2, @pad_left + 1)

    # Read screen content
    screen = @runner.read_screen_array

    screen.each_with_index do |line, row|
      output << "|"
      line.each do |char_code|
        # Handle inverse video (high bit set in original Apple II)
        char = (char_code & 0x7F).chr
        char = ' ' if char_code < 0x20
        output << char
      end
      output << "|"
      # Move to the next line at the correct horizontal position
      output << move_cursor(@pad_top + 3 + row, @pad_left + 1)
    end

    # Draw border bottom
    output << "+" << ("-" * SCREEN_COLS) << "+"

    output << NORMAL_VIDEO if @green_screen

    # Debug window (bordered, with padding above)
    if @debug
      # Add 1 line padding between screen and debug window
      debug_row = @pad_top + DISPLAY_HEIGHT + 2

      state = @runner.cpu_state
      dc = @runner.bus.disk_controller
      mode = @runner.bus.display_mode
      sim_type = (state[:simulator_type] || 'unknown').to_s.upcase

      # Line 1: Registers
      line1 = format("PC:%04X A:%02X X:%02X Y:%02X SP:%02X P:%02X",
                     state[:pc], state[:a], state[:x], state[:y],
                     state[:sp], state[:p])

      # Line 2: Sim type / cycles / speed / uptime
      line2 = format("Sim:%-6s Cyc:%s %s %.1ffps Up:%s",
                     sim_type, format_cycles(state[:cycles]),
                     format_hz(@current_hz), @fps,
                     format_uptime(@start_time))

      # Line 3: Disk / Key / video mode
      line3 = format("Disk:T%02d %s|Key:%-3s|%s",
                     dc.track, dc.motor_on ? "ON " : "OFF",
                     format_key(@last_key),
                     mode.to_s.upcase)

      # Line 4: Audio status with toggle count and activity
      speaker = @runner.bus.speaker
      audio_status = speaker.status
      activity = speaker.active? ? "*" : " "
      toggle_count = format_number(speaker.toggle_count)
      line4 = format("Audio:%s%s Tgl:%s Smp:%s",
                     audio_status, activity, toggle_count,
                     format_number(speaker.samples_written))

      # Pad/truncate lines to fit within border
      line1 = line1.ljust(SCREEN_COLS)[0, SCREEN_COLS]
      line2 = line2.ljust(SCREEN_COLS)[0, SCREEN_COLS]
      line3 = line3.ljust(SCREEN_COLS)[0, SCREEN_COLS]
      line4 = line4.ljust(SCREEN_COLS)[0, SCREEN_COLS]

      # Draw debug window with border (now 4 lines of content)
      output << move_cursor(debug_row, @pad_left + 1)
      output << "+" << ("-" * SCREEN_COLS) << "+"
      output << move_cursor(debug_row + 1, @pad_left + 1)
      output << "|" << line1 << "|"
      output << move_cursor(debug_row + 2, @pad_left + 1)
      output << "|" << line2 << "|"
      output << move_cursor(debug_row + 3, @pad_left + 1)
      output << "|" << line3 << "|"
      output << move_cursor(debug_row + 4, @pad_left + 1)
      output << "|" << line4 << "|"
      output << move_cursor(debug_row + 5, @pad_left + 1)
      output << "+" << ("-" * SCREEN_COLS) << "+"
    end

    # Show "DISK LOADING..." when disk motor is on (non-debug mode)
    status_row = @pad_top + DISPLAY_HEIGHT + 1
    if disk_motor_on? && !@debug
      output << move_cursor(status_row, @pad_left + 1)
      output << "DISK LOADING..."
      output << "     "  # Clear any leftover characters
    elsif !@debug
      # Clear the disk loading message when motor is off
      output << move_cursor(status_row, @pad_left + 1)
      output << "                    "  # Clear the line
    end

    print output
  end

  def format_cycles(cycles)
    if cycles >= 1_000_000
      format("%.1fM", cycles / 1_000_000.0)
    elsif cycles >= 1_000
      format("%.1fK", cycles / 1_000.0)
    else
      cycles.to_s
    end
  end

  def format_number(n)
    if n >= 1_000_000
      format("%.1fM", n / 1_000_000.0)
    elsif n >= 1_000
      format("%.1fK", n / 1_000.0)
    else
      n.to_s
    end
  end

  def update_performance_metrics
    now = Time.now
    current_cycles = @runner.cpu_state[:cycles]

    # Update Hz calculation every 0.5 seconds for stability
    elapsed = now - @last_time
    if elapsed >= 0.5
      cycles_delta = current_cycles - @last_cycles
      @current_hz = cycles_delta / elapsed
      @last_time = now
      @last_cycles = current_cycles
    end

    # Update FPS calculation every second
    fps_elapsed = now - @last_fps_time
    if fps_elapsed >= 1.0
      @fps = @fps_frame_count / fps_elapsed
      @last_fps_time = now
      @fps_frame_count = 0
    end
  end

  def format_hz(hz)
    if hz >= 1_000_000
      format("%.2fMHz", hz / 1_000_000.0)
    elsif hz >= 1_000
      format("%.1fKHz", hz / 1_000.0)
    else
      format("%.0fHz", hz)
    end
  end

  def format_uptime(start_time)
    elapsed = Time.now - start_time
    hours = (elapsed / 3600).to_i
    minutes = ((elapsed % 3600) / 60).to_i
    seconds = (elapsed % 60).to_i
    if hours > 0
      format("%d:%02d:%02d", hours, minutes, seconds)
    else
      format("%d:%02d", minutes, seconds)
    end
  end

  def format_key(ascii)
    return "---" unless ascii
    # Clear key display after 2 seconds
    return "---" if @last_key_time && (Time.now - @last_key_time) > 2.0

    case ascii
    when 0x00..0x1F
      # Control characters
      ctrl_char = (ascii + 0x40).chr
      "^#{ctrl_char}"
    when 0x20
      "SPC"
    when 0x7F
      "DEL"
    else
      "'#{ascii.chr}'"
    end
  end

  def disk_motor_on?
    @runner.bus.disk_controller.motor_on
  rescue
    false
  end

  def move_cursor(row, col)
    "#{ESC}[#{row};#{col}H"
  end

  def cleanup
    # Stop audio
    @runner.bus.stop_audio if @audio_enabled

    print SHOW_CURSOR
    print NORMAL_VIDEO
    # Position exit message below the display area
    # Account for bordered debug window (6 lines) + padding (2 lines) + disk loading line
    exit_row = @pad_top + DISPLAY_HEIGHT + (@debug ? 9 : 3)
    print move_cursor(exit_row, 1)
    puts "Apple ][ emulator terminated."
  end
end

# Demo program: Simple echo program that reads keyboard and displays on screen
def create_demo_program
  # Simple 6502 program that:
  # 1. Clears screen
  # 2. Prints "APPLE ][ READY" message
  # 3. Echoes keyboard input to screen
  asm = []

  # ORG $0800
  # Zero page variables
  cursor_lo = 0x00
  cursor_hi = 0x01

  # INIT: Set up cursor at start of text page
  asm << 0xA9 << 0x00        # LDA #$00
  asm << 0x85 << cursor_lo   # STA $00 (cursor low)
  asm << 0xA9 << 0x04        # LDA #$04
  asm << 0x85 << cursor_hi   # STA $01 (cursor high)

  # Clear text page
  asm << 0xA0 << 0x00        # LDY #$00
  asm << 0xA9 << 0xA0        # LDA #$A0 (space with high bit set)
  # CLEAR_LOOP:
  clear_loop = asm.length
  asm << 0x91 << cursor_lo   # STA ($00),Y
  asm << 0xC8                # INY
  asm << 0xD0 << 0xFB        # BNE CLEAR_LOOP (-5)
  asm << 0xE6 << cursor_hi   # INC $01
  asm << 0xA5 << cursor_hi   # LDA $01
  asm << 0xC9 << 0x08        # CMP #$08
  asm << 0xD0 << 0xF3        # BNE CLEAR_LOOP (-13)

  # Reset cursor to start
  asm << 0xA9 << 0x00        # LDA #$00
  asm << 0x85 << cursor_lo   # STA $00
  asm << 0xA9 << 0x04        # LDA #$04
  asm << 0x85 << cursor_hi   # STA $01

  # Print "READY" message
  message = "APPLE ][ READY\r"
  message.each_byte do |b|
    b = b | 0x80 # Set high bit for Apple II normal video
    asm << 0xA9 << b         # LDA #char
    asm << 0x20              # JSR PRINT_CHAR (we'll fill in address)
    print_char_addr = asm.length + 40 # Approximate offset
    asm << (print_char_addr & 0xFF) << ((print_char_addr >> 8) & 0xFF)
  end

  # Main loop: read keyboard and echo
  # MAIN_LOOP:
  main_loop = asm.length
  asm << 0xAD << 0x00 << 0xC0  # LDA $C000 (read keyboard)
  asm << 0x10 << 0xFB          # BPL MAIN_LOOP (wait for key)
  asm << 0x8D << 0x10 << 0xC0  # STA $C010 (clear strobe)
  asm << 0x29 << 0x7F          # AND #$7F (mask high bit)
  asm << 0xC9 << 0x0D          # CMP #$0D (carriage return?)
  asm << 0xF0 << 0x10          # BEQ NEW_LINE
  asm << 0x09 << 0x80          # ORA #$80 (set high bit for display)
  asm << 0x20                  # JSR PRINT_CHAR
  print_char_offset = asm.length
  asm << 0x00 << 0x00          # (placeholder)
  jmp_main = asm.length
  asm << 0x4C                  # JMP MAIN_LOOP
  asm << (main_loop & 0xFF) << (((main_loop >> 8) + 0x08) & 0xFF)

  # NEW_LINE: Handle carriage return
  new_line = asm.length
  # Move cursor to next line
  asm << 0x18                  # CLC
  asm << 0xA5 << cursor_lo     # LDA $00
  asm << 0x69 << 0x28          # ADC #$28 (40 columns)
  asm << 0x85 << cursor_lo     # STA $00
  asm << 0xA5 << cursor_hi     # LDA $01
  asm << 0x69 << 0x00          # ADC #$00
  asm << 0x85 << cursor_hi     # STA $01
  # Check for screen wrap
  asm << 0xC9 << 0x08          # CMP #$08
  asm << 0x90 << 0x04          # BCC NO_WRAP
  asm << 0xA9 << 0x04          # LDA #$04
  asm << 0x85 << cursor_hi     # STA $01
  # NO_WRAP:
  asm << 0x4C                  # JMP MAIN_LOOP
  asm << (main_loop & 0xFF) << (((main_loop >> 8) + 0x08) & 0xFF)

  # PRINT_CHAR: Print character in A to screen
  print_char = asm.length
  asm << 0xA0 << 0x00          # LDY #$00
  asm << 0x91 << cursor_lo     # STA ($00),Y
  asm << 0xE6 << cursor_lo     # INC $00
  asm << 0xD0 << 0x02          # BNE NO_CARRY
  asm << 0xE6 << cursor_hi     # INC $01
  # NO_CARRY:
  asm << 0x60                  # RTS

  # Fix up JSR addresses
  print_char_addr_full = 0x0800 + print_char
  asm[print_char_offset] = print_char_addr_full & 0xFF
  asm[print_char_offset + 1] = (print_char_addr_full >> 8) & 0xFF

  # Fix up JSRs in message printing
  idx = 0
  while idx < main_loop
    if asm[idx] == 0x20 # JSR
      asm[idx + 1] = print_char_addr_full & 0xFF
      asm[idx + 2] = (print_char_addr_full >> 8) & 0xFF
      idx += 3
    else
      idx += 1
    end
  end

  # Fix up NEW_LINE branch offset
  new_line_offset = new_line - (jmp_main - 2)
  # The BEQ after CMP #$0D needs to jump to NEW_LINE
  beq_offset_idx = main_loop + 11 # Position of BEQ operand
  asm[beq_offset_idx] = (new_line - (beq_offset_idx + 1)) & 0xFF

  asm
end

# Parse command line options
options = {
  speed: 10_000,
  debug: false,
  green: false,
  demo: false,
  mode: :native,  # Simulator mode: native, ruby, or hdl
  hires: false,
  hires_width: 80,
  audio: true  # Audio enabled by default
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: bin/apple2 [options] [program.bin]"
  opts.separator ""
  opts.separator "Apple ][ Terminal Emulator - 6502 CPU Simulation"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-r", "--rom FILE", "Load ROM file (default address: $F800)") do |v|
    options[:rom] = v
  end

  opts.on("-a", "--address ADDR", "Load address for program (hex, default: 0800)") do |v|
    options[:load_addr] = v.to_i(16)
  end

  opts.on("--rom-address ADDR", "Load address for ROM (hex, default: F800)") do |v|
    options[:rom_addr] = v.to_i(16)
  end

  opts.on("-s", "--speed CYCLES", Integer, "Cycles per frame (default: 10000)") do |v|
    options[:speed] = v
  end

  opts.on("-d", "--debug", "Show CPU state in status line") do
    options[:debug] = true
  end

  opts.on("-g", "--green", "Green phosphor screen effect") do
    options[:green] = true
  end

  opts.on("-m", "--mode TYPE", [:native, :ruby, :hdl], "Simulator mode: native (default), ruby, hdl") do |v|
    options[:mode] = v
  end

  opts.on("--demo", "Run built-in demo program") do
    options[:demo] = true
  end

  opts.on("-H", "--hires", "Enable hi-res graphics rendering (uses braille characters)") do
    options[:hires] = true
  end

  opts.on("--hires-width WIDTH", Integer, "Hi-res display width in chars (default: 80)") do |v|
    options[:hires_width] = v
  end

  opts.on("--disk FILE", "Load disk image (.dsk) into drive 1") do |v|
    options[:disk] = v
  end

  opts.on("--disk2 FILE", "Load disk image (.dsk) into drive 2") do |v|
    options[:disk2] = v
  end

  opts.on("-b", "--bin FILE", "Load binary file into memory (use -a for address)") do |v|
    options[:bin] = v
  end

  opts.on("-e", "--entry ADDR", "Entry point address (hex, default: load address)") do |v|
    options[:entry] = v.to_i(16)
  end

  opts.on("--init-hires", "Initialize HIRES mode soft switches before start") do
    options[:init_hires] = true
  end

  opts.on("-k", "--karateka", "Load Karateka memory dump (ready to play)") do
    options[:karateka] = true
    options[:hires] = true  # Karateka uses hi-res graphics mode
  end

  opts.on("--no-audio", "Disable audio output") do
    options[:audio] = false
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

parser.parse!(ARGV)

# Create terminal
terminal = Apple2Terminal.new(options)

# Load ROM if specified
if options[:rom]
  rom_addr = options[:rom_addr] || 0xF800
  terminal.load_rom(options[:rom], base_addr: rom_addr)
end

# Load disk images if specified
if options[:disk]
  unless File.exist?(options[:disk])
    puts "Error: Disk image not found: #{options[:disk]}"
    exit 1
  end
  terminal.load_disk(options[:disk], drive: 0)
end

if options[:disk2]
  unless File.exist?(options[:disk2])
    puts "Error: Disk image not found: #{options[:disk2]}"
    exit 1
  end
  terminal.load_disk(options[:disk2], drive: 1)
end

# Load Karateka memory dump if --karateka specified
if options[:karateka]
  karateka_bin = File.expand_path('../../software/disks/karateka_mem.bin', __FILE__)
  unless File.exist?(karateka_bin)
    puts "Error: Karateka memory dump not found: #{karateka_bin}"
    puts "Run: rake cli:apple2:disk:memdump to generate it"
    exit 1
  end

  # Karateka needs the Apple II ROM for ROM routines
  rom_file = File.expand_path('../../software/roms/appleiigo.rom', __FILE__)
  unless File.exist?(rom_file)
    puts "Error: AppleIIGo ROM not found: #{rom_file}"
    puts "Download from: https://a2go.applearchives.com/roms/"
    exit 1
  end

  # Load ROM first (at $D000), then memory dump (at $0000)
  terminal.load_rom(rom_file, base_addr: 0xD000)
  terminal.load_program(karateka_bin, base_addr: 0x0000)
  terminal.setup_reset_vector(0xB82A)  # Entry point from memory dump
  options[:init_hires] = true  # Karateka runs in HIRES mode
end

# Load program file if specified (via argument or --bin option)
program_file = ARGV.shift || options[:bin]
if program_file
  unless File.exist?(program_file)
    puts "Error: Program file not found: #{program_file}"
    exit 1
  end
  load_addr = options[:load_addr] || 0x0800
  entry_point = options[:entry] || load_addr
  terminal.load_program(program_file, base_addr: load_addr)
  # Only set reset vector if no ROM is loaded (ROM handles its own reset)
  terminal.setup_reset_vector(entry_point) unless options[:rom]
elsif options[:karateka]
  # Already handled above
elsif options[:demo]
  # Load demo program
  puts "Loading built-in demo program..."
  demo = create_demo_program
  terminal.load_program_bytes(demo, base_addr: 0x0800)
  terminal.setup_reset_vector(0x0800)
elsif options[:rom]
  # ROM loaded - it will handle startup (e.g., boot from disk)
  # No additional program needed
elsif options[:disk]
  # Disk loaded but no ROM - need a ROM to boot from disk
  puts parser
  puts ""
  puts "Error: Disk loading requires a ROM (use --rom or --appleiigo)."
  exit 1
else
  puts parser
  puts ""
  puts "Error: No program specified. Use --demo for built-in demo or provide a binary file."
  exit 1
end

# Initialize HIRES mode soft switches if requested
# This is useful for loading memory dumps that were captured in HIRES mode
if options[:init_hires]
  runner = terminal.runner
  # For native mode, also set video state on the CPU (soft switches are handled in Rust)
  if runner.native?
    runner.cpu.set_video_state(false, false, false, true)  # text=false, mixed=false, page2=false, hires=true
  end
  bus = runner.bus
  bus.read(0xC050)  # TXTCLR - graphics mode
  bus.read(0xC052)  # MIXCLR - full screen
  bus.read(0xC054)  # PAGE1 - page 1
  bus.read(0xC057)  # HIRES - hi-res mode
end

# Run the emulator
terminal.run
