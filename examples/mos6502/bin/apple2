#!/usr/bin/env ruby
# frozen_string_literal: true

# Apple ][ Terminal Emulator
# Runs a 6502 simulation with Apple II-style memory-mapped I/O

require 'io/console'
require 'optparse'

$LOAD_PATH.unshift File.expand_path('../../../lib', __dir__)
$LOAD_PATH.unshift File.expand_path('../utilities', __dir__)

require 'rhdl'
require 'apple2_harness'

# Apple II Terminal class
class Apple2Terminal
  SCREEN_ROWS = 24
  SCREEN_COLS = 40

  # Display dimensions including border
  DISPLAY_WIDTH = SCREEN_COLS + 2   # 42 (40 + 2 border chars)
  DISPLAY_HEIGHT = SCREEN_ROWS + 2  # 26 (24 + 2 border lines)

  # ANSI escape codes
  ESC = "\e"
  CLEAR_SCREEN = "#{ESC}[2J"
  MOVE_HOME = "#{ESC}[H"
  HIDE_CURSOR = "#{ESC}[?25l"
  SHOW_CURSOR = "#{ESC}[?25h"
  REVERSE_VIDEO = "#{ESC}[7m"
  NORMAL_VIDEO = "#{ESC}[0m"
  GREEN_FG = "#{ESC}[32m"
  BLACK_BG = "#{ESC}[40m"
  BOLD = "#{ESC}[1m"

  attr_reader :runner, :running

  def initialize(options = {})
    @options = options
    # Use ISARunner for fast mode, HDL Runner for cycle-accurate mode
    @runner = if options[:fast]
                Apple2Harness::ISARunner.new
              else
                Apple2Harness::Runner.new
              end
    @running = false
    @last_screen = nil
    @cycles_per_frame = options[:speed] || 10_000
    @debug = options[:debug] || false
    @green_screen = options[:green] || false
    @fast_mode = options[:fast] || false

    # Terminal size and padding for centering
    @term_rows = 24
    @term_cols = 80
    @pad_top = 0
    @pad_left = 0
    update_terminal_size
  end

  def update_terminal_size
    if $stdout.respond_to?(:winsize)
      rows, cols = $stdout.winsize
      @term_rows = [rows, DISPLAY_HEIGHT].max
      @term_cols = [cols, DISPLAY_WIDTH].max
    end

    # Calculate padding to center the display
    display_height = @debug ? DISPLAY_HEIGHT + 1 : DISPLAY_HEIGHT
    @pad_top = [(@term_rows - display_height) / 2, 0].max
    @pad_left = [(@term_cols - DISPLAY_WIDTH) / 2, 0].max
  end

  def load_rom(path, base_addr: 0xF800)
    puts "Loading ROM: #{path} at $#{base_addr.to_s(16).upcase}"
    bytes = File.binread(path)
    @runner.load_rom(bytes, base_addr: base_addr)
  end

  def load_program(path, base_addr: 0x0800)
    puts "Loading program: #{path} at $#{base_addr.to_s(16).upcase}"
    bytes = File.binread(path)
    @runner.load_ram(bytes, base_addr: base_addr)
  end

  def load_program_bytes(bytes, base_addr: 0x0800)
    @runner.load_ram(bytes, base_addr: base_addr)
  end

  def load_disk(path, drive: 0)
    puts "Loading disk: #{path} into drive #{drive + 1}"
    @runner.load_disk(path, drive: drive)
  end

  def setup_reset_vector(addr)
    # Set reset vector to point to our program
    @runner.bus.write(0xFFFC, addr & 0xFF)
    @runner.bus.write(0xFFFD, (addr >> 8) & 0xFF)
  end

  def run
    @running = true
    @resize_pending = false

    # Set up signal handler for clean exit
    trap('INT') { stop }
    trap('TERM') { stop }

    # Handle terminal resize
    trap('WINCH') do
      @resize_pending = true
    end

    mode = @fast_mode ? "ISA (fast)" : "HDL (cycle-accurate)"
    puts "Starting Apple ][ emulator... [#{mode} mode]"
    puts "Press Ctrl+C to exit"
    puts "Press any key to continue..."
    sleep 0.5

    # Reset the CPU
    @runner.reset

    # Enter raw terminal mode
    begin
      IO.console.raw do
        print CLEAR_SCREEN
        print HIDE_CURSOR

        main_loop
      end
    ensure
      cleanup
    end
  end

  def stop
    @running = false
  end

  private

  def main_loop
    frame_count = 0

    while @running && !@runner.halted?
      # Handle terminal resize
      if @resize_pending
        @resize_pending = false
        update_terminal_size
        print CLEAR_SCREEN
      end

      # Check for keyboard input (non-blocking)
      handle_keyboard_input

      # Run CPU cycles
      @runner.run_steps(@cycles_per_frame)

      # Update display if screen changed
      if @runner.screen_dirty? || frame_count % 10 == 0
        render_screen
        @runner.clear_screen_dirty
      end

      frame_count += 1

      # Small delay to prevent CPU spinning
      sleep 0.016 # ~60fps
    end

    if @runner.halted?
      # Position halted message below the display (after debug and disk loading lines)
      halt_row = @pad_top + DISPLAY_HEIGHT + (@debug ? 3 : 2)
      print move_cursor(halt_row, @pad_left + 1)
      puts "CPU HALTED at PC=$#{@runner.cpu_state[:pc].to_s(16).upcase.rjust(4, '0')}"
      print move_cursor(halt_row + 1, @pad_left + 1)
      puts "Press any key to exit..."
      IO.console.getch
    end
  end

  def handle_keyboard_input
    # Non-blocking read
    char = IO.console.read_nonblock(1)
    return unless char

    ascii = char.ord

    # Handle special keys
    case ascii
    when 3 # Ctrl+C
      stop
      return
    when 27 # ESC - check for arrow keys
      handle_escape_sequence
      return
    when 127, 8 # Backspace/Delete
      ascii = 0x08 # Apple II backspace
    when 10, 13 # Enter/Return
      ascii = 0x0D # Apple II carriage return
    end

    # Convert lowercase to uppercase for Apple II
    ascii = ascii - 32 if ascii >= 97 && ascii <= 122

    # Inject the key
    @runner.inject_key(ascii)
  rescue IO::WaitReadable, Errno::EAGAIN
    # No input available, continue
  end

  def handle_escape_sequence
    # Try to read arrow key sequence
    begin
      seq = IO.console.read_nonblock(2)
      case seq
      when '[A' # Up arrow
        @runner.inject_key(0x0B) # Ctrl+K (up)
      when '[B' # Down arrow
        @runner.inject_key(0x0A) # Ctrl+J (down)
      when '[C' # Right arrow
        @runner.inject_key(0x15) # Ctrl+U (right)
      when '[D' # Left arrow
        @runner.inject_key(0x08) # Ctrl+H (left/backspace)
      end
    rescue IO::WaitReadable, Errno::EAGAIN
      # Just ESC key pressed
      @runner.inject_key(0x1B)
    end
  end

  def render_screen
    output = String.new

    # Move cursor to the top-left corner of the centered display
    # ANSI cursor positions are 1-based
    output << move_cursor(@pad_top + 1, @pad_left + 1)

    if @green_screen
      output << GREEN_FG
      output << BLACK_BG
    end

    # Horizontal padding string (reused for each line)
    h_pad = " " * @pad_left

    # Draw border top
    output << "+" << ("-" * SCREEN_COLS) << "+"
    output << move_cursor(@pad_top + 2, @pad_left + 1)

    # Read screen content
    screen = @runner.read_screen_array

    screen.each_with_index do |line, row|
      output << "|"
      line.each do |char_code|
        # Handle inverse video (high bit set in original Apple II)
        char = (char_code & 0x7F).chr
        char = ' ' if char_code < 0x20
        output << char
      end
      output << "|"
      # Move to the next line at the correct horizontal position
      output << move_cursor(@pad_top + 3 + row, @pad_left + 1)
    end

    # Draw border bottom
    output << "+" << ("-" * SCREEN_COLS) << "+"

    output << NORMAL_VIDEO if @green_screen

    # Status line (centered below the display)
    status_row = @pad_top + DISPLAY_HEIGHT + 1
    if @debug
      state = @runner.cpu_state
      status = format("PC:%04X A:%02X X:%02X Y:%02X SP:%02X P:%02X Cycles:%d",
                      state[:pc], state[:a], state[:x], state[:y],
                      state[:sp], state[:p], state[:cycles])
      output << move_cursor(status_row, @pad_left + 1)
      output << status
      status_row += 1
    end

    # Show "DISK LOADING..." when disk motor is on
    if disk_motor_on?
      output << move_cursor(status_row, @pad_left + 1)
      output << "DISK LOADING..."
      output << "     "  # Clear any leftover characters
    else
      # Clear the disk loading message when motor is off
      output << move_cursor(status_row, @pad_left + 1)
      output << "                    "  # Clear the line
    end

    print output
  end

  def disk_motor_on?
    @runner.bus.disk_controller.motor_on
  rescue
    false
  end

  def move_cursor(row, col)
    "#{ESC}[#{row};#{col}H"
  end

  def cleanup
    print SHOW_CURSOR
    print NORMAL_VIDEO
    # Position exit message below the display area
    # Account for debug line and disk loading line
    exit_row = @pad_top + DISPLAY_HEIGHT + (@debug ? 4 : 3)
    print move_cursor(exit_row, 1)
    puts "Apple ][ emulator terminated."
  end
end

# Demo program: Simple echo program that reads keyboard and displays on screen
def create_demo_program
  # Simple 6502 program that:
  # 1. Clears screen
  # 2. Prints "APPLE ][ READY" message
  # 3. Echoes keyboard input to screen
  asm = []

  # ORG $0800
  # Zero page variables
  cursor_lo = 0x00
  cursor_hi = 0x01

  # INIT: Set up cursor at start of text page
  asm << 0xA9 << 0x00        # LDA #$00
  asm << 0x85 << cursor_lo   # STA $00 (cursor low)
  asm << 0xA9 << 0x04        # LDA #$04
  asm << 0x85 << cursor_hi   # STA $01 (cursor high)

  # Clear text page
  asm << 0xA0 << 0x00        # LDY #$00
  asm << 0xA9 << 0xA0        # LDA #$A0 (space with high bit set)
  # CLEAR_LOOP:
  clear_loop = asm.length
  asm << 0x91 << cursor_lo   # STA ($00),Y
  asm << 0xC8                # INY
  asm << 0xD0 << 0xFB        # BNE CLEAR_LOOP (-5)
  asm << 0xE6 << cursor_hi   # INC $01
  asm << 0xA5 << cursor_hi   # LDA $01
  asm << 0xC9 << 0x08        # CMP #$08
  asm << 0xD0 << 0xF3        # BNE CLEAR_LOOP (-13)

  # Reset cursor to start
  asm << 0xA9 << 0x00        # LDA #$00
  asm << 0x85 << cursor_lo   # STA $00
  asm << 0xA9 << 0x04        # LDA #$04
  asm << 0x85 << cursor_hi   # STA $01

  # Print "READY" message
  message = "APPLE ][ READY\r"
  message.each_byte do |b|
    b = b | 0x80 # Set high bit for Apple II normal video
    asm << 0xA9 << b         # LDA #char
    asm << 0x20              # JSR PRINT_CHAR (we'll fill in address)
    print_char_addr = asm.length + 40 # Approximate offset
    asm << (print_char_addr & 0xFF) << ((print_char_addr >> 8) & 0xFF)
  end

  # Main loop: read keyboard and echo
  # MAIN_LOOP:
  main_loop = asm.length
  asm << 0xAD << 0x00 << 0xC0  # LDA $C000 (read keyboard)
  asm << 0x10 << 0xFB          # BPL MAIN_LOOP (wait for key)
  asm << 0x8D << 0x10 << 0xC0  # STA $C010 (clear strobe)
  asm << 0x29 << 0x7F          # AND #$7F (mask high bit)
  asm << 0xC9 << 0x0D          # CMP #$0D (carriage return?)
  asm << 0xF0 << 0x10          # BEQ NEW_LINE
  asm << 0x09 << 0x80          # ORA #$80 (set high bit for display)
  asm << 0x20                  # JSR PRINT_CHAR
  print_char_offset = asm.length
  asm << 0x00 << 0x00          # (placeholder)
  jmp_main = asm.length
  asm << 0x4C                  # JMP MAIN_LOOP
  asm << (main_loop & 0xFF) << (((main_loop >> 8) + 0x08) & 0xFF)

  # NEW_LINE: Handle carriage return
  new_line = asm.length
  # Move cursor to next line
  asm << 0x18                  # CLC
  asm << 0xA5 << cursor_lo     # LDA $00
  asm << 0x69 << 0x28          # ADC #$28 (40 columns)
  asm << 0x85 << cursor_lo     # STA $00
  asm << 0xA5 << cursor_hi     # LDA $01
  asm << 0x69 << 0x00          # ADC #$00
  asm << 0x85 << cursor_hi     # STA $01
  # Check for screen wrap
  asm << 0xC9 << 0x08          # CMP #$08
  asm << 0x90 << 0x04          # BCC NO_WRAP
  asm << 0xA9 << 0x04          # LDA #$04
  asm << 0x85 << cursor_hi     # STA $01
  # NO_WRAP:
  asm << 0x4C                  # JMP MAIN_LOOP
  asm << (main_loop & 0xFF) << (((main_loop >> 8) + 0x08) & 0xFF)

  # PRINT_CHAR: Print character in A to screen
  print_char = asm.length
  asm << 0xA0 << 0x00          # LDY #$00
  asm << 0x91 << cursor_lo     # STA ($00),Y
  asm << 0xE6 << cursor_lo     # INC $00
  asm << 0xD0 << 0x02          # BNE NO_CARRY
  asm << 0xE6 << cursor_hi     # INC $01
  # NO_CARRY:
  asm << 0x60                  # RTS

  # Fix up JSR addresses
  print_char_addr_full = 0x0800 + print_char
  asm[print_char_offset] = print_char_addr_full & 0xFF
  asm[print_char_offset + 1] = (print_char_addr_full >> 8) & 0xFF

  # Fix up JSRs in message printing
  idx = 0
  while idx < main_loop
    if asm[idx] == 0x20 # JSR
      asm[idx + 1] = print_char_addr_full & 0xFF
      asm[idx + 2] = (print_char_addr_full >> 8) & 0xFF
      idx += 3
    else
      idx += 1
    end
  end

  # Fix up NEW_LINE branch offset
  new_line_offset = new_line - (jmp_main - 2)
  # The BEQ after CMP #$0D needs to jump to NEW_LINE
  beq_offset_idx = main_loop + 11 # Position of BEQ operand
  asm[beq_offset_idx] = (new_line - (beq_offset_idx + 1)) & 0xFF

  asm
end

# Parse command line options
options = {
  speed: 10_000,
  debug: false,
  green: false,
  demo: false,
  fast: true  # Default to fast (ISA emulation) mode
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: bin/apple2 [options] [program.bin]"
  opts.separator ""
  opts.separator "Apple ][ Terminal Emulator - 6502 CPU Simulation"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-r", "--rom FILE", "Load ROM file (default address: $F800)") do |v|
    options[:rom] = v
  end

  opts.on("-a", "--address ADDR", "Load address for program (hex, default: 0800)") do |v|
    options[:load_addr] = v.to_i(16)
  end

  opts.on("--rom-address ADDR", "Load address for ROM (hex, default: F800)") do |v|
    options[:rom_addr] = v.to_i(16)
  end

  opts.on("-s", "--speed CYCLES", Integer, "Cycles per frame (default: 10000)") do |v|
    options[:speed] = v
  end

  opts.on("-d", "--debug", "Show CPU state in status line") do
    options[:debug] = true
  end

  opts.on("-g", "--green", "Green phosphor screen effect") do
    options[:green] = true
  end

  opts.on("-f", "--fast", "Use fast ISA-level simulator (default)") do
    options[:fast] = true
  end

  opts.on("--hdl", "Use HDL cycle-accurate simulator (slower)") do
    options[:fast] = false
  end

  opts.on("--demo", "Run built-in demo program") do
    options[:demo] = true
  end

  opts.on("--disk FILE", "Load disk image (.dsk) into drive 1") do |v|
    options[:disk] = v
  end

  opts.on("--disk2 FILE", "Load disk image (.dsk) into drive 2") do |v|
    options[:disk2] = v
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

parser.parse!(ARGV)

# Create terminal
terminal = Apple2Terminal.new(options)

# Load ROM if specified
if options[:rom]
  rom_addr = options[:rom_addr] || 0xF800
  terminal.load_rom(options[:rom], base_addr: rom_addr)
end

# Load disk images if specified
if options[:disk]
  unless File.exist?(options[:disk])
    puts "Error: Disk image not found: #{options[:disk]}"
    exit 1
  end
  terminal.load_disk(options[:disk], drive: 0)
end

if options[:disk2]
  unless File.exist?(options[:disk2])
    puts "Error: Disk image not found: #{options[:disk2]}"
    exit 1
  end
  terminal.load_disk(options[:disk2], drive: 1)
end

# Load program file if specified
program_file = ARGV.shift
if program_file
  load_addr = options[:load_addr] || 0x0800
  terminal.load_program(program_file, base_addr: load_addr)
  terminal.setup_reset_vector(load_addr)
elsif options[:demo]
  # Load demo program
  puts "Loading built-in demo program..."
  demo = create_demo_program
  terminal.load_program_bytes(demo, base_addr: 0x0800)
  terminal.setup_reset_vector(0x0800)
elsif options[:rom]
  # ROM loaded - it will handle startup (e.g., boot from disk)
  # No additional program needed
elsif options[:disk]
  # Disk loaded but no ROM - need a ROM to boot from disk
  puts parser
  puts ""
  puts "Error: Disk loading requires a ROM (use --rom or --appleiigo)."
  exit 1
else
  puts parser
  puts ""
  puts "Error: No program specified. Use --demo for built-in demo or provide a binary file."
  exit 1
end

# Run the emulator
terminal.run
