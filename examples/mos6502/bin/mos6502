#!/usr/bin/env ruby
# frozen_string_literal: true

# Apple ][ Terminal Emulator
# Runs a 6502 simulation with Apple II-style memory-mapped I/O

require 'io/console'
require 'optparse'

$LOAD_PATH.unshift File.expand_path('../../../lib', __dir__)
$LOAD_PATH.unshift File.expand_path('../utilities', __dir__)

require 'rhdl'
require 'apple2_harness'
require 'isa_simulator'
require 'ruby_isa_runner'
require 'ir_simulator_runner'
require 'color_renderer'

# Apple II Terminal class
class Apple2Terminal
  SCREEN_ROWS = 24
  SCREEN_COLS = 40

  # Hi-res display dimensions
  HIRES_WIDTH = 140   # braille chars (280 pixels / 2)
  HIRES_HEIGHT = 48   # braille chars (192 pixels / 4)

  # Display dimensions including border
  DISPLAY_WIDTH = SCREEN_COLS + 2   # 42 (40 + 2 border chars)
  DISPLAY_HEIGHT = SCREEN_ROWS + 2  # 26 (24 + 2 border lines)

  # ANSI escape codes
  ESC = "\e"
  CLEAR_SCREEN = "#{ESC}[2J"
  MOVE_HOME = "#{ESC}[H"
  HIDE_CURSOR = "#{ESC}[?25l"
  SHOW_CURSOR = "#{ESC}[?25h"
  REVERSE_VIDEO = "#{ESC}[7m"
  NORMAL_VIDEO = "#{ESC}[0m"
  GREEN_FG = "#{ESC}[32m"
  BLACK_BG = "#{ESC}[40m"
  BOLD = "#{ESC}[1m"

  attr_reader :runner, :running

  def initialize(options = {})
    @options = options
    @mode = options[:mode] || :isa
    @sim_backend = options[:sim] || :jit

    # Create runner based on mode and sim backend
    @runner = case @mode
              when :isa
                # ISA mode ignores --sim option
                runner = Apple2Harness::ISARunner.new
                # Verify we got native, warn if fell back to ruby
                unless runner.native?
                  warn "Warning: Native simulator not available, using Ruby ISA simulator"
                end
                @sim_type = runner.native? ? :native : :ruby
                runner
              when :hdl
                # HDL mode uses IR-based simulators
                @sim_type = :"hdl_#{@sim_backend}"
                IRSimulatorRunner.new(@sim_backend)
              when :netlist
                # Netlist mode uses gate-level simulators (not yet implemented)
                raise "Netlist mode not yet implemented"
              else
                raise "Unknown mode: #{@mode}. Valid modes: isa, hdl, netlist"
              end

    @running = false
    @last_screen = nil
    # HDL/Netlist mode may be slower than ISA, adjust default speed accordingly
    # ISA mode: ~1.022 MHz at 60fps
    # HDL interpret: much slower, use smaller cycles
    # HDL jit/compile: faster, but still slower than ISA
    default_speed = case @mode
                    when :isa then 17_030
                    when :hdl
                      case @sim_backend
                      when :interpret then 100
                      when :jit then 5_000
                      when :compile then 10_000
                      end
                    when :netlist then 10
                    else 17_030
                    end
    @cycles_per_frame = options[:speed] || default_speed
    @debug = options[:debug] || false
    @green_screen = options[:green] || false
    @hires_mode = options[:hires] || false
    @color_mode = options[:color] || false
    @preferred_hires_width = options[:hires_width]
    @hires_width = @preferred_hires_width || (@color_mode ? 140 : 80)
    @audio_enabled = options[:audio] != false

    # Terminal size and padding for centering
    @term_rows = 24
    @term_cols = 80
    @pad_top = 0
    @pad_left = 0
    @hires_pad_top = 0
    @hires_pad_left = 0
    update_terminal_size

    # Performance monitoring
    @start_time = nil
    @start_cycles = 0
    @last_cycles = 0
    @last_time = nil
    @current_hz = 0.0
    @frame_count = 0
    @fps = 0.0
    @last_fps_time = nil
    @fps_frame_count = 0

    # Input tracking for debug
    @last_key = nil
    @last_key_time = nil

    # Keyboard mode: :normal passes keys to emulator, :command handles runtime controls
    @keyboard_mode = :normal
  end

  def update_terminal_size
    if $stdout.respond_to?(:winsize) && $stdout.tty?
      begin
        rows, cols = $stdout.winsize
        @term_rows = [rows, DISPLAY_HEIGHT].max
        @term_cols = [cols, DISPLAY_WIDTH].max
      rescue Errno::ENOTTY
        # Not a TTY, use defaults
      end
    end

    # Calculate padding to center the text display
    # Debug mode adds bordered debug window: 1 padding + 6 lines (border + 4 content + border)
    # Non-debug adds 1 for disk loading indicator
    display_height = @debug ? DISPLAY_HEIGHT + 7 : DISPLAY_HEIGHT
    @pad_top = [(@term_rows - display_height) / 2, 0].max
    @pad_left = [(@term_cols - DISPLAY_WIDTH) / 2, 0].max

    # Auto-adjust hires width to fit terminal
    # Use preferred width if set, otherwise use mode-appropriate default capped to terminal
    default_width = @color_mode ? 140 : 80
    preferred = @preferred_hires_width || default_width
    @hires_width = [preferred, @term_cols].min

    # Calculate padding for hires display
    # Color mode uses half-blocks (2 pixels/char = 96 lines), braille uses 4 pixels/char (48 lines)
    # Debug mode adds bordered debug window: 2 gap + 6 lines (border + 4 content + border)
    # Non-debug adds 1 for disk loading indicator
    hires_content_height = @color_mode ? 96 : HIRES_HEIGHT
    debug_panel_height = @debug ? 8 : 1  # 6 lines debug box + 2 gap, or 1 line for disk status
    total_content_height = hires_content_height + debug_panel_height
    hires_display_width = @hires_width

    # If content fits in terminal, center it
    # If content doesn't fit, position so debug panel is visible at bottom (sacrifice top of hires)
    if total_content_height <= @term_rows
      # Content fits - center it
      @hires_pad_top = [(@term_rows - total_content_height) / 2, 0].max
    else
      # Content doesn't fit - ensure debug panel is visible at bottom
      # Calculate pad_top so that the bottom of content aligns with bottom of terminal
      @hires_pad_top = @term_rows - total_content_height
      # Allow negative pad_top - this will push hires content up off screen
      # but keep debug panel visible
    end
    @hires_pad_left = [(@term_cols - hires_display_width) / 2, 0].max
  end

  def load_rom(path, base_addr: 0xF800)
    puts "Loading ROM: #{path} at $#{base_addr.to_s(16).upcase}"
    bytes = File.binread(path)
    @runner.load_rom(bytes, base_addr: base_addr)
  end

  def load_program(path, base_addr: 0x0800)
    puts "Loading program: #{path} at $#{base_addr.to_s(16).upcase}"
    bytes = File.binread(path)
    @runner.load_ram(bytes, base_addr: base_addr)
  end

  def load_program_bytes(bytes, base_addr: 0x0800)
    @runner.load_ram(bytes, base_addr: base_addr)
  end

  def load_disk(path, drive: 0)
    puts "Loading disk: #{path} into drive #{drive + 1}"
    @runner.load_disk(path, drive: drive)
  end

  def setup_reset_vector(addr)
    # Set reset vector to point to our program
    # For native mode, write to CPU memory; otherwise write to bus
    if @sim_type == :native && @runner.respond_to?(:native?) && @runner.native?
      @runner.cpu.poke(0xFFFC, addr & 0xFF)
      @runner.cpu.poke(0xFFFD, (addr >> 8) & 0xFF)
    else
      @runner.bus.write(0xFFFC, addr & 0xFF)
      @runner.bus.write(0xFFFD, (addr >> 8) & 0xFF)
    end
  end

  def run
    @running = true
    @resize_pending = false

    # Set up signal handler for clean exit - use exit! for immediate termination
    trap('INT') do
      @running = false
      # Force exit if we're stuck in a long operation
      Thread.new { sleep 0.5; exit!(0) if @running == false }
    end
    trap('TERM') { @running = false; exit!(0) }

    # Handle terminal resize
    trap('WINCH') do
      @resize_pending = true
    end

    mode_names = {
      native: "Native ISA",
      ruby: "Ruby ISA",
      hdl_interpret: "HDL (IR Interpret)",
      hdl_jit: "HDL (IR JIT)",
      hdl_compile: "HDL (IR Compile)",
      netlist_interpret: "Netlist (Interpret)",
      netlist_jit: "Netlist (JIT)",
      netlist_compile: "Netlist (Compile)"
    }
    mode = mode_names[@sim_type] || @sim_type.to_s
    audio_status = @audio_enabled ? "Audio ON" : "Audio OFF"
    puts "Starting Apple ][ emulator... [#{mode} mode, #{audio_status}]"
    if @mode == :hdl && @sim_backend == :interpret
      puts "WARNING: HDL interpret mode is slow (for verification only)"
    elsif @mode == :netlist
      puts "WARNING: Netlist mode is very slow (for verification only)"
    end
    puts "Press Ctrl+C to exit"
    puts "Press any key to continue..."
    sleep 0.5

    # Start audio if enabled
    if @audio_enabled
      @runner.bus.start_audio
    end

    # Reset the CPU
    @runner.reset

    # Initialize performance monitoring
    @start_time = Time.now
    @start_cycles = @runner.cpu_state[:cycles]
    @last_time = @start_time
    @last_cycles = @start_cycles
    @last_fps_time = @start_time
    @fps_frame_count = 0

    # Enter raw terminal mode
    begin
      IO.console.raw do
        print CLEAR_SCREEN
        print HIDE_CURSOR

        main_loop
      end
    ensure
      cleanup
    end
  end

  def stop
    @running = false
  end

  private

  def main_loop
    @frame_count = 0

    while @running && !@runner.halted?
      # Handle terminal resize
      if @resize_pending
        @resize_pending = false
        update_terminal_size
        print CLEAR_SCREEN
      end

      frame_start = Process.clock_gettime(Process::CLOCK_MONOTONIC)

      # Check for keyboard input (non-blocking)
      handle_keyboard_input

      # Get cycle count before running
      cycles_before = @runner.cycle_count

      # Run CPU cycles
      @runner.run_steps(@cycles_per_frame)

      # Get cycles actually executed and update bus timing
      cycles_after = @runner.cycle_count
      cycles_executed = cycles_after - cycles_before
      @runner.bus.tick(cycles_executed) if cycles_executed > 0

      # Update performance metrics
      update_performance_metrics

      # Update display if screen changed
      if @runner.screen_dirty? || @frame_count % 10 == 0
        render_screen
        @runner.clear_screen_dirty
      end

      @frame_count += 1
      @fps_frame_count += 1

      # Dynamic frame timing - sleep only if frame was faster than 16.67ms (60fps)
      frame_elapsed = Process.clock_gettime(Process::CLOCK_MONOTONIC) - frame_start
      sleep_time = 0.01667 - frame_elapsed
      sleep(sleep_time) if sleep_time > 0
    end

    if @runner.halted?
      # Position halted message below the display (after debug and disk loading lines)
      halt_row = @pad_top + DISPLAY_HEIGHT + (@debug ? 7 : 2)
      print move_cursor(halt_row, @pad_left + 1)
      puts "CPU HALTED at PC=$#{@runner.cpu_state[:pc].to_s(16).upcase.rjust(4, '0')}"
      print move_cursor(halt_row + 1, @pad_left + 1)
      puts "Press any key to exit..."
      IO.console.getch
    end
  end

  def handle_keyboard_input
    # Non-blocking read
    char = IO.console.read_nonblock(1)
    return unless char

    ascii = char.ord

    # Handle special keys that work in all modes
    case ascii
    when 3 # Ctrl+C
      stop
      return
    when 27 # ESC - toggle command mode or check for arrow keys
      handle_escape_sequence
      return
    end

    # In command mode, handle runtime controls instead of passing to emulator
    if @keyboard_mode == :command
      handle_command_key(ascii)
      return
    end

    # Normal mode: pass key to emulator
    case ascii
    when 127, 8 # Backspace/Delete
      ascii = 0x08 # Apple II backspace
    when 10, 13 # Enter/Return
      ascii = 0x0D # Apple II carriage return
    end

    # Convert lowercase to uppercase for Apple II
    ascii = ascii - 32 if ascii >= 97 && ascii <= 122

    # Track for debug display
    @last_key = ascii
    @last_key_time = Time.now

    # Inject the key
    @runner.inject_key(ascii)
  rescue IO::WaitReadable, Errno::EAGAIN
    # No input available, continue
  end

  def handle_escape_sequence
    # Try to read arrow key sequence
    # Wait briefly for more bytes (escape sequences come in quick succession)
    if IO.select([IO.console], nil, nil, 0.05)
      begin
        seq = IO.console.read_nonblock(2)
        if @keyboard_mode == :command
          # In command mode, arrow keys control speed
          # HDL/Netlist mode uses smaller increments since it's much slower
          speed_delta = @mode == :isa ? 1000 : 100
          case seq
          when '[C' # Right arrow - increase speed
            @cycles_per_frame += speed_delta
          when '[D' # Left arrow - decrease speed
            @cycles_per_frame = [@cycles_per_frame - speed_delta, speed_delta].max
          end
        else
          # In normal mode, arrow keys go to emulator
          case seq
          when '[A' # Up arrow
            @runner.inject_key(0x0B) # Ctrl+K (up)
          when '[B' # Down arrow
            @runner.inject_key(0x0A) # Ctrl+J (down)
          when '[C' # Right arrow
            @runner.inject_key(0x15) # Ctrl+U (right)
          when '[D' # Left arrow
            @runner.inject_key(0x08) # Ctrl+H (left/backspace)
          end
        end
      rescue IO::WaitReadable, Errno::EAGAIN
        # Incomplete sequence, treat as just ESC
        handle_esc_key
      end
    else
      # No more bytes within timeout - just ESC key pressed
      handle_esc_key
    end
  end

  def handle_esc_key
    # Toggle command mode (only in debug mode)
    if @debug
      @keyboard_mode = @keyboard_mode == :normal ? :command : :normal
    else
      # In non-debug mode, pass ESC to emulator
      @runner.inject_key(0x1B)
    end
  end

  def handle_command_key(ascii)
    case ascii
    when 72, 104 # H or h - toggle hires mode
      @hires_mode = !@hires_mode
      print CLEAR_SCREEN
    when 67, 99 # C or c - toggle color mode
      @color_mode = !@color_mode
      @hires_mode = true if @color_mode  # Color implies hires
      # Recalculate width for the mode (auto-adjusts to terminal size)
      update_terminal_size
      print CLEAR_SCREEN
    when 65, 97 # A or a - toggle audio
      if @audio_enabled
        @runner.bus.stop_audio
        @audio_enabled = false
      else
        @runner.bus.start_audio
        @audio_enabled = true
      end
    end
  end

  def render_screen
    # Sync video state from native CPU to bus (for soft switches handled in Rust)
    @runner.sync_video_state if @runner.respond_to?(:sync_video_state)

    # Sync speaker toggles from native CPU to Ruby speaker (for audio generation)
    @runner.sync_speaker_state if @runner.respond_to?(:sync_speaker_state)

    # Check if we should render hi-res graphics
    # @hires_mode is the user-controlled toggle (H key in command mode)
    # It overrides the soft switch state for display purposes
    if @hires_mode
      render_hires_screen
    else
      render_text_screen
    end
  end

  def render_hires_screen
    output = String.new

    if @green_screen && !@color_mode
      output << GREEN_FG
      output << BLACK_BG
    end

    # Render hi-res using color or braille characters
    if @color_mode
      hires_output = @runner.bus.render_hires_color(chars_wide: @hires_width)
    elsif @runner.native? && @runner.respond_to?(:cpu) && @runner.cpu.respond_to?(:render_hires_braille)
      # Use fast Rust rendering when available (native mode)
      hires_output = @runner.cpu.render_hires_braille(@hires_width, true)
    else
      hires_output = @runner.bus.render_hires_braille(chars_wide: @hires_width, invert: true)
    end
    hires_lines = hires_output.split("\n")

    # Render each line of hires output with proper centering
    hires_lines.each_with_index do |line, row|
      output << move_cursor(@hires_pad_top + row + 1, @hires_pad_left + 1)
      output << line
    end

    output << NORMAL_VIDEO if @green_screen

    # Debug window (bordered, with padding above)
    if @debug
      # Debug window width matches hires display width
      debug_width = @hires_width - 2  # Account for border chars

      # Add 1 line padding between hires display and debug window
      debug_row = @hires_pad_top + hires_lines.length + 2

      state = @runner.cpu_state
      dc = @runner.bus.disk_controller
      sim_type = (state[:simulator_type] || 'unknown').to_s.upcase

      # Line 1: Registers
      mode_label = @color_mode ? "[COLOR]" : "[HIRES]"
      line1 = format("PC:%04X A:%02X X:%02X Y:%02X SP:%02X P:%02X %s",
                     state[:pc], state[:a], state[:x], state[:y],
                     state[:sp], state[:p], mode_label)

      # Line 2: Sim type / cycles / speed / uptime
      line2 = format("Sim:%-6s Cyc:%s %s %.1ffps Spd:%s",
                     sim_type, format_cycles(state[:cycles]),
                     format_hz(@current_hz), @fps,
                     format_number(@cycles_per_frame))

      # Line 3: Disk IO / keyboard IO / keyboard mode
      kb_mode = @keyboard_mode == :command ? "CMD" : "NRM"
      line3 = format("Disk:T%02d %s | Key:%-3s | KB:%s",
                     dc.track, dc.motor_on ? "ON " : "OFF",
                     format_key(@last_key),
                     kb_mode)

      # Line 4: Audio status with toggle count and activity
      speaker = @runner.bus.speaker
      audio_status = speaker.status
      activity = speaker.active? ? "*" : " "
      toggle_count = format_number(speaker.toggle_count)
      line4 = format("Audio:%s%s Tgl:%s Smp:%s",
                     audio_status, activity, toggle_count,
                     format_number(speaker.samples_written))

      # Pad/truncate lines to fit within border
      line1 = line1.ljust(debug_width)[0, debug_width]
      line2 = line2.ljust(debug_width)[0, debug_width]
      line3 = line3.ljust(debug_width)[0, debug_width]
      line4 = line4.ljust(debug_width)[0, debug_width]

      # Draw debug window with border (now 4 lines of content)
      output << move_cursor(debug_row, @hires_pad_left + 1)
      output << "+" << ("-" * debug_width) << "+"
      output << move_cursor(debug_row + 1, @hires_pad_left + 1)
      output << "|" << line1 << "|"
      output << move_cursor(debug_row + 2, @hires_pad_left + 1)
      output << "|" << line2 << "|"
      output << move_cursor(debug_row + 3, @hires_pad_left + 1)
      output << "|" << line3 << "|"
      output << move_cursor(debug_row + 4, @hires_pad_left + 1)
      output << "|" << line4 << "|"
      output << move_cursor(debug_row + 5, @hires_pad_left + 1)
      output << "+" << ("-" * debug_width) << "+"
    elsif disk_motor_on?
      status_row = @hires_pad_top + hires_lines.length + 1
      output << move_cursor(status_row, @hires_pad_left + 1)
      output << "DISK LOADING..."
    end

    print output
  end

  def render_text_screen
    output = String.new

    # Move cursor to the top-left corner of the centered display
    # ANSI cursor positions are 1-based
    output << move_cursor(@pad_top + 1, @pad_left + 1)

    if @green_screen
      output << GREEN_FG
      output << BLACK_BG
    end

    # Horizontal padding string (reused for each line)
    h_pad = " " * @pad_left

    # Draw border top
    output << "+" << ("-" * SCREEN_COLS) << "+"
    output << move_cursor(@pad_top + 2, @pad_left + 1)

    # Read screen content
    screen = @runner.read_screen_array

    screen.each_with_index do |line, row|
      output << "|"
      line.each do |char_code|
        # Handle inverse video (high bit set in original Apple II)
        char = (char_code & 0x7F).chr
        char = ' ' if char_code < 0x20
        output << char
      end
      output << "|"
      # Move to the next line at the correct horizontal position
      output << move_cursor(@pad_top + 3 + row, @pad_left + 1)
    end

    # Draw border bottom
    output << "+" << ("-" * SCREEN_COLS) << "+"

    output << NORMAL_VIDEO if @green_screen

    # Debug window (bordered, with padding above)
    if @debug
      # Add 1 line padding between screen and debug window
      debug_row = @pad_top + DISPLAY_HEIGHT + 2

      state = @runner.cpu_state
      dc = @runner.bus.disk_controller
      mode = @runner.bus.display_mode
      sim_type = (state[:simulator_type] || 'unknown').to_s.upcase

      # Line 1: Registers
      line1 = format("PC:%04X A:%02X X:%02X Y:%02X SP:%02X P:%02X",
                     state[:pc], state[:a], state[:x], state[:y],
                     state[:sp], state[:p])

      # Line 2: Sim type / cycles / speed / uptime
      line2 = format("Sim:%-6s Cyc:%s %s %.1ffps Spd:%s",
                     sim_type, format_cycles(state[:cycles]),
                     format_hz(@current_hz), @fps,
                     format_number(@cycles_per_frame))

      # Line 3: Disk / Key / video mode / keyboard mode
      kb_mode = @keyboard_mode == :command ? "CMD" : "NRM"
      line3 = format("Disk:T%02d %s|Key:%-3s|%s|KB:%s",
                     dc.track, dc.motor_on ? "ON " : "OFF",
                     format_key(@last_key),
                     mode.to_s.upcase,
                     kb_mode)

      # Line 4: Audio status with toggle count and activity
      speaker = @runner.bus.speaker
      audio_status = speaker.status
      activity = speaker.active? ? "*" : " "
      toggle_count = format_number(speaker.toggle_count)
      line4 = format("Audio:%s%s Tgl:%s Smp:%s",
                     audio_status, activity, toggle_count,
                     format_number(speaker.samples_written))

      # Pad/truncate lines to fit within border
      line1 = line1.ljust(SCREEN_COLS)[0, SCREEN_COLS]
      line2 = line2.ljust(SCREEN_COLS)[0, SCREEN_COLS]
      line3 = line3.ljust(SCREEN_COLS)[0, SCREEN_COLS]
      line4 = line4.ljust(SCREEN_COLS)[0, SCREEN_COLS]

      # Draw debug window with border (now 4 lines of content)
      output << move_cursor(debug_row, @pad_left + 1)
      output << "+" << ("-" * SCREEN_COLS) << "+"
      output << move_cursor(debug_row + 1, @pad_left + 1)
      output << "|" << line1 << "|"
      output << move_cursor(debug_row + 2, @pad_left + 1)
      output << "|" << line2 << "|"
      output << move_cursor(debug_row + 3, @pad_left + 1)
      output << "|" << line3 << "|"
      output << move_cursor(debug_row + 4, @pad_left + 1)
      output << "|" << line4 << "|"
      output << move_cursor(debug_row + 5, @pad_left + 1)
      output << "+" << ("-" * SCREEN_COLS) << "+"
    end

    # Show "DISK LOADING..." when disk motor is on (non-debug mode)
    status_row = @pad_top + DISPLAY_HEIGHT + 1
    if disk_motor_on? && !@debug
      output << move_cursor(status_row, @pad_left + 1)
      output << "DISK LOADING..."
      output << "     "  # Clear any leftover characters
    elsif !@debug
      # Clear the disk loading message when motor is off
      output << move_cursor(status_row, @pad_left + 1)
      output << "                    "  # Clear the line
    end

    print output
  end

  def format_cycles(cycles)
    if cycles >= 1_000_000
      format("%.1fM", cycles / 1_000_000.0)
    elsif cycles >= 1_000
      format("%.1fK", cycles / 1_000.0)
    else
      cycles.to_s
    end
  end

  def format_number(n)
    if n >= 1_000_000
      format("%.1fM", n / 1_000_000.0)
    elsif n >= 1_000
      format("%.1fK", n / 1_000.0)
    else
      n.to_s
    end
  end

  def update_performance_metrics
    now = Time.now
    current_cycles = @runner.cpu_state[:cycles]

    # Update Hz calculation every 0.5 seconds for stability
    elapsed = now - @last_time
    if elapsed >= 0.5
      cycles_delta = current_cycles - @last_cycles
      @current_hz = cycles_delta / elapsed
      @last_time = now
      @last_cycles = current_cycles
    end

    # Update FPS calculation every second
    fps_elapsed = now - @last_fps_time
    if fps_elapsed >= 1.0
      @fps = @fps_frame_count / fps_elapsed
      @last_fps_time = now
      @fps_frame_count = 0
    end
  end

  def format_hz(hz)
    if hz >= 1_000_000
      format("%.2fMHz", hz / 1_000_000.0)
    elsif hz >= 1_000
      format("%.1fKHz", hz / 1_000.0)
    else
      format("%.0fHz", hz)
    end
  end

  def format_uptime(start_time)
    elapsed = Time.now - start_time
    hours = (elapsed / 3600).to_i
    minutes = ((elapsed % 3600) / 60).to_i
    seconds = (elapsed % 60).to_i
    if hours > 0
      format("%d:%02d:%02d", hours, minutes, seconds)
    else
      format("%d:%02d", minutes, seconds)
    end
  end

  def format_key(ascii)
    return "---" unless ascii
    # Clear key display after 2 seconds
    return "---" if @last_key_time && (Time.now - @last_key_time) > 2.0

    case ascii
    when 0x00..0x1F
      # Control characters
      ctrl_char = (ascii + 0x40).chr
      "^#{ctrl_char}"
    when 0x20
      "SPC"
    when 0x7F
      "DEL"
    else
      "'#{ascii.chr}'"
    end
  end

  def disk_motor_on?
    @runner.bus.disk_controller.motor_on
  rescue
    false
  end

  def move_cursor(row, col)
    "#{ESC}[#{row};#{col}H"
  end

  def cleanup
    # Stop audio
    @runner.bus.stop_audio if @audio_enabled

    print SHOW_CURSOR
    print NORMAL_VIDEO
    # Position exit message below the display area
    # Account for bordered debug window (6 lines) + padding (2 lines) + disk loading line
    exit_row = @pad_top + DISPLAY_HEIGHT + (@debug ? 9 : 3)
    print move_cursor(exit_row, 1)
    puts "Apple ][ emulator terminated."
  end
end

# Demo program: Simple echo program that reads keyboard and displays on screen
def create_demo_program
  # Simple 6502 program that:
  # 1. Clears screen
  # 2. Prints "APPLE ][ READY" message
  # 3. Echoes keyboard input to screen
  asm = []

  # ORG $0800
  # Zero page variables
  cursor_lo = 0x00
  cursor_hi = 0x01

  # INIT: Set up cursor at start of text page
  asm << 0xA9 << 0x00        # LDA #$00
  asm << 0x85 << cursor_lo   # STA $00 (cursor low)
  asm << 0xA9 << 0x04        # LDA #$04
  asm << 0x85 << cursor_hi   # STA $01 (cursor high)

  # Clear text page
  asm << 0xA0 << 0x00        # LDY #$00
  asm << 0xA9 << 0xA0        # LDA #$A0 (space with high bit set)
  # CLEAR_LOOP:
  clear_loop = asm.length
  asm << 0x91 << cursor_lo   # STA ($00),Y
  asm << 0xC8                # INY
  asm << 0xD0 << 0xFB        # BNE CLEAR_LOOP (-5)
  asm << 0xE6 << cursor_hi   # INC $01
  asm << 0xA5 << cursor_hi   # LDA $01
  asm << 0xC9 << 0x08        # CMP #$08
  asm << 0xD0 << 0xF3        # BNE CLEAR_LOOP (-13)

  # Reset cursor to start
  asm << 0xA9 << 0x00        # LDA #$00
  asm << 0x85 << cursor_lo   # STA $00
  asm << 0xA9 << 0x04        # LDA #$04
  asm << 0x85 << cursor_hi   # STA $01

  # Print "READY" message
  message = "APPLE ][ READY\r"
  message.each_byte do |b|
    b = b | 0x80 # Set high bit for Apple II normal video
    asm << 0xA9 << b         # LDA #char
    asm << 0x20              # JSR PRINT_CHAR (we'll fill in address)
    print_char_addr = asm.length + 40 # Approximate offset
    asm << (print_char_addr & 0xFF) << ((print_char_addr >> 8) & 0xFF)
  end

  # Main loop: read keyboard and echo
  # MAIN_LOOP:
  main_loop = asm.length
  asm << 0xAD << 0x00 << 0xC0  # LDA $C000 (read keyboard)
  asm << 0x10 << 0xFB          # BPL MAIN_LOOP (wait for key)
  asm << 0x8D << 0x10 << 0xC0  # STA $C010 (clear strobe)
  asm << 0x29 << 0x7F          # AND #$7F (mask high bit)
  asm << 0xC9 << 0x0D          # CMP #$0D (carriage return?)
  asm << 0xF0 << 0x10          # BEQ NEW_LINE
  asm << 0x09 << 0x80          # ORA #$80 (set high bit for display)
  asm << 0x20                  # JSR PRINT_CHAR
  print_char_offset = asm.length
  asm << 0x00 << 0x00          # (placeholder)
  jmp_main = asm.length
  asm << 0x4C                  # JMP MAIN_LOOP
  asm << (main_loop & 0xFF) << (((main_loop >> 8) + 0x08) & 0xFF)

  # NEW_LINE: Handle carriage return
  new_line = asm.length
  # Move cursor to next line
  asm << 0x18                  # CLC
  asm << 0xA5 << cursor_lo     # LDA $00
  asm << 0x69 << 0x28          # ADC #$28 (40 columns)
  asm << 0x85 << cursor_lo     # STA $00
  asm << 0xA5 << cursor_hi     # LDA $01
  asm << 0x69 << 0x00          # ADC #$00
  asm << 0x85 << cursor_hi     # STA $01
  # Check for screen wrap
  asm << 0xC9 << 0x08          # CMP #$08
  asm << 0x90 << 0x04          # BCC NO_WRAP
  asm << 0xA9 << 0x04          # LDA #$04
  asm << 0x85 << cursor_hi     # STA $01
  # NO_WRAP:
  asm << 0x4C                  # JMP MAIN_LOOP
  asm << (main_loop & 0xFF) << (((main_loop >> 8) + 0x08) & 0xFF)

  # PRINT_CHAR: Print character in A to screen
  print_char = asm.length
  asm << 0xA0 << 0x00          # LDY #$00
  asm << 0x91 << cursor_lo     # STA ($00),Y
  asm << 0xE6 << cursor_lo     # INC $00
  asm << 0xD0 << 0x02          # BNE NO_CARRY
  asm << 0xE6 << cursor_hi     # INC $01
  # NO_CARRY:
  asm << 0x60                  # RTS

  # Fix up JSR addresses
  print_char_addr_full = 0x0800 + print_char
  asm[print_char_offset] = print_char_addr_full & 0xFF
  asm[print_char_offset + 1] = (print_char_addr_full >> 8) & 0xFF

  # Fix up JSRs in message printing
  idx = 0
  while idx < main_loop
    if asm[idx] == 0x20 # JSR
      asm[idx + 1] = print_char_addr_full & 0xFF
      asm[idx + 2] = (print_char_addr_full >> 8) & 0xFF
      idx += 3
    else
      idx += 1
    end
  end

  # Fix up NEW_LINE branch offset
  new_line_offset = new_line - (jmp_main - 2)
  # The BEQ after CMP #$0D needs to jump to NEW_LINE
  beq_offset_idx = main_loop + 11 # Position of BEQ operand
  asm[beq_offset_idx] = (new_line - (beq_offset_idx + 1)) & 0xFF

  asm
end

# Parse command line options
options = {
  speed: 17_030,  # ~1.022 MHz at 60fps (Apple II target: 1.023 MHz)
  debug: false,
  green: false,
  demo: false,
  mode: :isa,      # Simulator mode: isa, hdl, or netlist
  sim: :jit,       # Sim backend: interpret, jit, or compile (ignored for ISA mode)
  hires: false,
  hires_width: nil,  # Auto-calculated based on mode and terminal size
  color: false,  # NTSC artifact color rendering
  audio: true  # Audio enabled by default
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: bin/apple2 [options] [program.bin]"
  opts.separator ""
  opts.separator "Apple ][ Terminal Emulator - 6502 CPU Simulation"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-r", "--rom FILE", "Load ROM file (address auto-detected from size)") do |v|
    options[:rom] = v
  end

  opts.on("-a", "--address ADDR", "Load address for program (hex, default: 0800)") do |v|
    options[:load_addr] = v.to_i(16)
  end

  opts.on("--rom-address ADDR", "Load address for ROM (hex, default: F800)") do |v|
    options[:rom_addr] = v.to_i(16)
  end

  opts.on("-s", "--speed CYCLES", Integer, "Cycles per frame (default: 17030)") do |v|
    options[:speed] = v
  end

  opts.on("-d", "--debug", "Show CPU state in status line") do
    options[:debug] = true
  end

  opts.on("-g", "--green", "Green phosphor screen effect") do
    options[:green] = true
  end

  opts.on("-m", "--mode TYPE", [:isa, :hdl, :netlist], "Simulator mode: isa (default), hdl, netlist") do |v|
    options[:mode] = v
  end

  opts.on("--sim TYPE", [:interpret, :jit, :compile], "Sim backend: interpret, jit (default), compile (ignored for ISA mode)") do |v|
    options[:sim] = v
  end

  opts.on("--demo", "Run built-in demo program") do
    options[:demo] = true
  end

  opts.on("-H", "--hires", "Enable hi-res graphics rendering (uses braille characters)") do
    options[:hires] = true
  end

  opts.on("-C", "--color", "Enable NTSC artifact color rendering (implies --hires)") do
    options[:color] = true
    options[:hires] = true
  end

  opts.on("--hires-width WIDTH", Integer, "Hi-res display width in chars (auto-adjusts to terminal)") do |v|
    options[:hires_width] = v
  end

  opts.on("--disk FILE", "Load disk image (.dsk) into drive 1") do |v|
    options[:disk] = v
  end

  opts.on("--disk2 FILE", "Load disk image (.dsk) into drive 2") do |v|
    options[:disk2] = v
  end

  opts.on("-b", "--bin FILE", "Load binary file into memory (use -a for address)") do |v|
    options[:bin] = v
  end

  opts.on("-e", "--entry ADDR", "Entry point address (hex, default: load address)") do |v|
    options[:entry] = v.to_i(16)
  end

  opts.on("--init-hires", "Initialize HIRES mode soft switches before start") do
    options[:init_hires] = true
  end

  opts.on("-k", "--karateka", "Load Karateka memory dump (enables color mode)") do
    options[:karateka] = true
    options[:hires] = true   # Karateka uses hi-res graphics mode
    options[:color] = true   # Enable NTSC artifact colors
  end

  opts.on("--appleiigo", "Load AppleIIGo ROM and boot from it") do
    options[:appleiigo] = true
  end

  opts.on("--no-audio", "Disable audio output") do
    options[:audio] = false
  end

  opts.on("--dry-run", "Load configuration and display engine info without running emulator") do
    options[:dry_run] = true
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

parser.parse!(ARGV)

# Create terminal
terminal = Apple2Terminal.new(options)

# Load ROM if specified
if options[:rom]
  unless File.exist?(options[:rom])
    puts "Error: ROM file not found: #{options[:rom]}"
    exit 1
  end

  # Auto-detect ROM base address from file size if not specified
  rom_size = File.size(options[:rom])
  rom_addr = options[:rom_addr] || case rom_size
                                   when 0x4000 then 0xC000  # 16KB ROM at $C000
                                   when 0x3000 then 0xD000  # 12KB ROM at $D000
                                   when 0x2000 then 0xE000  # 8KB ROM at $E000
                                   when 0x0800 then 0xF800  # 2KB ROM at $F800
                                   else 0x10000 - rom_size  # Auto-align to end at $FFFF
                                   end
  terminal.load_rom(options[:rom], base_addr: rom_addr)
end

# Load disk images if specified
if options[:disk]
  unless File.exist?(options[:disk])
    puts "Error: Disk image not found: #{options[:disk]}"
    exit 1
  end

  # Auto-load AppleIIGo ROM if disk specified without ROM
  unless options[:rom] || options[:appleiigo] || options[:karateka]
    rom_file = File.expand_path('../../software/roms/appleiigo.rom', __FILE__)
    if File.exist?(rom_file)
      puts "Auto-loading AppleIIGo ROM for disk boot..."
      terminal.load_rom(rom_file, base_addr: 0xD000)
      options[:appleiigo] = true  # Mark as loaded for later logic
    else
      puts "Error: AppleIIGo ROM not found: #{rom_file}"
      puts "Download from: https://a2go.applearchives.com/roms/"
      puts "Or specify a ROM with --rom option"
      exit 1
    end
  end

  terminal.load_disk(options[:disk], drive: 0)
end

if options[:disk2]
  unless File.exist?(options[:disk2])
    puts "Error: Disk image not found: #{options[:disk2]}"
    exit 1
  end
  terminal.load_disk(options[:disk2], drive: 1)
end

# Load Karateka memory dump if --karateka specified
if options[:karateka]
  karateka_bin = File.expand_path('../../software/disks/karateka_mem.bin', __FILE__)
  unless File.exist?(karateka_bin)
    puts "Error: Karateka memory dump not found: #{karateka_bin}"
    puts "Run: rake cli:apple2:disk:memdump to generate it"
    exit 1
  end

  # Karateka needs the Apple II ROM for ROM routines
  rom_file = File.expand_path('../../software/roms/appleiigo.rom', __FILE__)
  unless File.exist?(rom_file)
    puts "Error: AppleIIGo ROM not found: #{rom_file}"
    puts "Download from: https://a2go.applearchives.com/roms/"
    exit 1
  end

  # Load ROM first (at $D000), then memory dump (at $0000)
  terminal.load_rom(rom_file, base_addr: 0xD000)
  terminal.load_program(karateka_bin, base_addr: 0x0000)
  terminal.setup_reset_vector(0xB82A)  # Entry point from memory dump
  options[:init_hires] = true  # Karateka runs in HIRES mode
end

# Load AppleIIGo ROM if --appleiigo specified
if options[:appleiigo]
  rom_file = File.expand_path('../../software/roms/appleiigo.rom', __FILE__)
  unless File.exist?(rom_file)
    puts "Error: AppleIIGo ROM not found: #{rom_file}"
    puts "Download from: https://a2go.applearchives.com/roms/"
    exit 1
  end

  # Load 12KB ROM at $D000 (covers $D000-$FFFF including reset vector)
  terminal.load_rom(rom_file, base_addr: 0xD000)
  # ROM's reset vector at $FFFC/$FFFD will be used automatically
end

# Load program file if specified (via argument or --bin option)
program_file = ARGV.shift || options[:bin]
if program_file
  unless File.exist?(program_file)
    puts "Error: Program file not found: #{program_file}"
    exit 1
  end
  load_addr = options[:load_addr] || 0x0800
  entry_point = options[:entry] || load_addr
  terminal.load_program(program_file, base_addr: load_addr)
  # Only set reset vector if no ROM is loaded (ROM handles its own reset)
  terminal.setup_reset_vector(entry_point) unless options[:rom]
elsif options[:karateka]
  # Already handled above
elsif options[:appleiigo]
  # ROM loaded above - it will handle startup
elsif options[:demo]
  # Load demo program
  puts "Loading built-in demo program..."
  demo = create_demo_program
  terminal.load_program_bytes(demo, base_addr: 0x0800)
  terminal.setup_reset_vector(0x0800)
elsif options[:rom]
  # ROM loaded - it will handle startup (e.g., boot from disk)
  # No additional program needed
else
  puts parser
  puts ""
  puts "Error: No program specified. Use --demo for built-in demo or provide a binary file."
  exit 1
end

# Initialize HIRES mode soft switches if requested
# This is useful for loading memory dumps that were captured in HIRES mode
if options[:init_hires]
  runner = terminal.runner
  # For native mode, also set video state on the CPU (soft switches are handled in Rust)
  if runner.native? && runner.respond_to?(:cpu) && runner.cpu.respond_to?(:set_video_state)
    runner.cpu.set_video_state(false, false, false, true)  # text=false, mixed=false, page2=false, hires=true
  end
  bus = runner.bus
  bus.read(0xC050)  # TXTCLR - graphics mode
  bus.read(0xC052)  # MIXCLR - full screen
  bus.read(0xC054)  # PAGE1 - page 1
  bus.read(0xC057)  # HIRES - hi-res mode
  # Push video state to native CPU so it matches Ruby bus
  terminal.runner.sync_video_to_native if terminal.runner.respond_to?(:sync_video_to_native)
end

# Handle dry-run mode - output engine info and memory dump without running
if options[:dry_run]
  require 'json'
  runner = terminal.runner
  info = runner.dry_run_info
  puts JSON.pretty_generate(info)
  exit 0
end

# Run the emulator
terminal.run
