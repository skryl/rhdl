# Chapter 8: The MOS 6502

## Overview

Deep dive into a real CPU: the legendary MOS 6502 that powered the Apple II, Commodore 64, and NES.

## Key Concepts

### Why the 6502?

- Simple enough to understand completely
- Complex enough to be interesting
- Well-documented (50 years of study)
- Still relevant (similar to modern embedded CPUs)
- Powered iconic computers

### 6502 Architecture

**Registers:**
- A (Accumulator): 8-bit, main working register
- X (Index): 8-bit, array indexing
- Y (Index): 8-bit, array indexing
- SP (Stack Pointer): 8-bit, stack at $0100-$01FF
- PC (Program Counter): 16-bit
- P (Status): N V - B D I Z C

**Status Flags:**
- N (Negative): Bit 7 of result
- V (Overflow): Signed overflow
- B (Break): BRK instruction flag
- D (Decimal): BCD mode
- I (Interrupt): Interrupt disable
- Z (Zero): Result was zero
- C (Carry): Unsigned overflow

### Addressing Modes

The 6502's richness comes from its addressing modes:

**Immediate:** `LDA #$42`
- Value follows opcode

**Zero Page:** `LDA $42`
- Fast access to first 256 bytes

**Zero Page,X:** `LDA $42,X`
- Zero page with X offset

**Absolute:** `LDA $1234`
- Full 16-bit address

**Absolute,X/Y:** `LDA $1234,X`
- Base address with index

**Indexed Indirect:** `LDA ($42,X)`
- Pointer table access

**Indirect Indexed:** `LDA ($42),Y`
- Array access through pointer

### Instruction Categories

**Load/Store:**
```
LDA, LDX, LDY  ; Load registers
STA, STX, STY  ; Store registers
```

**Transfer:**
```
TAX, TAY, TXA, TYA  ; Between registers
TSX, TXS            ; Stack pointer
```

**Arithmetic:**
```
ADC  ; Add with carry
SBC  ; Subtract with carry
INC, DEC  ; Memory increment/decrement
INX, INY, DEX, DEY  ; Register inc/dec
```

**Logic:**
```
AND, ORA, EOR  ; Bitwise operations
ASL, LSR       ; Shift left/right
ROL, ROR       ; Rotate through carry
BIT            ; Bit test
```

**Compare:**
```
CMP, CPX, CPY  ; Compare (subtract, set flags, discard)
```

**Branch:**
```
BEQ, BNE  ; Zero flag
BMI, BPL  ; Negative flag
BCC, BCS  ; Carry flag
BVC, BVS  ; Overflow flag
```

**Jump:**
```
JMP  ; Unconditional jump
JSR  ; Jump to subroutine
RTS  ; Return from subroutine
```

**Stack:**
```
PHA, PLA  ; Push/pull accumulator
PHP, PLP  ; Push/pull status
```

### The 6502 Pipeline

The 6502 has a primitive pipeline:
- While executing current instruction...
- Fetches next instruction's opcode
- This creates some "illegal" opcodes that do strange things

### Cycle Timing

Every instruction takes a specific number of cycles:
- `LDA #imm`: 2 cycles
- `LDA abs`: 4 cycles
- `LDA abs,X`: 4-5 cycles (page crossing adds 1)

This predictable timing was crucial for:
- Video sync (racing the beam)
- Music/sound timing
- Real-time systems

### The RHDL 6502 Implementation

```ruby
module RHDL::Examples::MOS6502
  class CPU < SimComponent
    input :clk
    input :reset
    input :irq
    input :nmi

    output :addr, width: 16
    output :data_out, width: 8
    input :data_in, width: 8
    output :rw  # 1 = read, 0 = write

    instance :alu, ALU
    instance :control, ControlUnit
    instance :datapath, Datapath
  end
end
```

## Hands-On Project: 6502 Programs

Write and run programs on the RHDL 6502:

```ruby
# Fibonacci sequence
program = assemble(<<~ASM)
  LDA #0      ; fib(0) = 0
  STA $00
  LDA #1      ; fib(1) = 1
  STA $01
  LDX #2      ; start at fib(2)
loop:
  LDA $FE,X   ; load fib(n-2)
  CLC
  ADC $FF,X   ; add fib(n-1)
  STA $00,X   ; store fib(n)
  INX
  CPX #10     ; compute 10 numbers
  BNE loop
  BRK
ASM
```

## Exercises

1. Write a multiplication routine (6502 has no MUL)
2. Implement a simple game loop
3. Study the differences between NMOS and CMOS 6502

---

## Notes and Ideas

- Visual: decode ROM showing instruction decode
- History: the MOS Technology story
- Show how NES games used cycle-exact timing
- Compare: 6502 vs Z80 vs 8080
- The illegal opcodes and what they do
- Why the 6502 is still manufactured today
