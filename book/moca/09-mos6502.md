# Chapter 10: The MOS 6502

## Overview

The MOS 6502, introduced in 1975 at $25 (when competitors cost $300), democratized computing. It powered:

- Apple I and Apple II
- Commodore 64
- Atari 2600
- Nintendo Entertainment System
- BBC Micro

With only 3,510 transistors, the 6502 is small enough to understand completely—yet capable enough to run real software.

## Architecture

### Registers

The 6502 is spartan compared to modern CPUs:

```
┌─────────────────────────────────────────────────────────────┐
│                    6502 REGISTERS                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   A  [████████]  8-bit   Accumulator (main work register)   │
│   X  [████████]  8-bit   Index register X                   │
│   Y  [████████]  8-bit   Index register Y                   │
│   SP [████████]  8-bit   Stack pointer (page $01xx)         │
│   PC [████████████████]  16-bit  Program counter            │
│   P  [NV-BDIZC]  8-bit   Processor status (flags)           │
│                                                              │
│   Flags: N=Negative V=Overflow B=Break D=Decimal            │
│          I=Interrupt Z=Zero C=Carry                         │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Memory Map

```
$0000-$00FF  Zero Page (fast access)
$0100-$01FF  Stack
$0200-$FFFF  General purpose / ROM
$FFFA-$FFFB  NMI vector
$FFFC-$FFFD  Reset vector
$FFFE-$FFFF  IRQ/BRK vector
```

### Addressing Modes

The 6502's power comes from its 13 addressing modes:

| Mode | Example | Description |
|------|---------|-------------|
| Immediate | `LDA #$42` | Load literal value |
| Zero Page | `LDA $42` | Load from zero page |
| Zero Page,X | `LDA $42,X` | Zero page + X index |
| Absolute | `LDA $1234` | Load from 16-bit address |
| Absolute,X | `LDA $1234,X` | Absolute + X index |
| Absolute,Y | `LDA $1234,Y` | Absolute + Y index |
| Indirect | `JMP ($1234)` | Jump to address at pointer |
| (Indirect,X) | `LDA ($42,X)` | Indexed indirect |
| (Indirect),Y | `LDA ($42),Y` | Indirect indexed |

## Instruction Set

### Load/Store

```asm
LDA #$42      ; A = $42
LDX $1000     ; X = memory[$1000]
LDY $1000,X   ; Y = memory[$1000 + X]
STA $2000     ; memory[$2000] = A
STX $00       ; zero page store (fast!)
STY $00,X     ; zero page indexed
```

### Arithmetic

```asm
ADC #$10      ; A = A + $10 + Carry
SBC #$05      ; A = A - $05 - !Carry
INC $00       ; memory[$00]++
DEC $00       ; memory[$00]--
INX           ; X++
DEY           ; Y--
```

### Logic

```asm
AND #$0F      ; A = A & $0F (mask low nibble)
ORA #$80      ; A = A | $80 (set high bit)
EOR #$FF      ; A = A ^ $FF (invert)
ASL A         ; A = A << 1 (arithmetic shift left)
LSR A         ; A = A >> 1 (logical shift right)
ROL A         ; Rotate left through carry
ROR A         ; Rotate right through carry
```

### Branching

```asm
BEQ label     ; Branch if Zero flag set
BNE label     ; Branch if Zero flag clear
BCS label     ; Branch if Carry set
BCC label     ; Branch if Carry clear
BMI label     ; Branch if Negative set
BPL label     ; Branch if Negative clear
JMP $1234     ; Unconditional jump
JSR $1234     ; Jump to subroutine
RTS           ; Return from subroutine
```

## Example: Multiply

The 6502 has no multiply instruction. Here's multiplication by repeated addition:

```asm
; Multiply A * X, result in A
; Destroys X
multiply:
    STA temp      ; Save multiplicand
    LDA #0        ; Clear result
    CPX #0        ; Check if multiplier is 0
    BEQ done
loop:
    CLC
    ADC temp      ; result += multiplicand
    DEX           ; multiplier--
    BNE loop      ; Loop until X = 0
done:
    RTS
```

## Why Study the 6502?

1. **Simplicity** - Small enough to understand every transistor
2. **Historical importance** - Shaped the personal computer revolution
3. **Still relevant** - NES homebrew, retro computing active today
4. **Educational** - Perfect complexity for learning CPU design
5. **Well-documented** - Visual transistor maps, cycle-accurate emulators

## The 6502 in Silicon

The 6502 was designed for minimal transistor count:

| Component | Transistors |
|-----------|-------------|
| ALU | ~400 |
| Registers | ~200 |
| Control logic | ~2,000 |
| Decode ROM | ~900 |
| **Total** | **3,510** |

Compare to a modern CPU: Intel i7 has ~2 billion transistors.

## Cycle Timing

The 6502 uses variable-length instruction cycles:

| Instruction | Cycles | Notes |
|-------------|--------|-------|
| LDA # | 2 | Immediate |
| LDA zp | 3 | Zero page |
| LDA abs | 4 | Absolute |
| LDA abs,X | 4-5 | +1 if page crossed |
| STA abs | 4 | |
| JMP | 3 | |
| JSR | 6 | Push return address |
| RTS | 6 | Pop return address |

## Building a 6502 in RHDL

The 6502 can be implemented in RHDL:

```
┌─────────────────────────────────────────────────────────────┐
│                    6502 COMPONENTS                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ALU ────────────────────── 8-bit add/sub/logic            │
│   Registers ──────────────── A, X, Y, SP, P                 │
│   PC Logic ───────────────── 16-bit with increment          │
│   Address Modes ──────────── 13 addressing mode decoders    │
│   Instruction Decoder ────── PLA-based decode               │
│   Control Sequencer ──────── Microcode state machine        │
│   Bus Interface ──────────── Data/address multiplexing      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Key Takeaways

1. **Constraints breed creativity** - 3,510 transistors did remarkable things
2. **Addressing modes matter** - They define how you interact with memory
3. **Simplicity enables understanding** - You can know every transistor
4. **The microcode pattern** - Complex instructions built from simple micro-ops
5. **Trade-offs everywhere** - Speed vs. transistor count vs. ease of use

> See [Appendix J](appendix-j-mos6502.md) for complete 6502 RHDL implementation with test suite.
