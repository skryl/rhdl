#!/usr/bin/env ruby
# frozen_string_literal: true

require "optparse"
require "rhdl"
require "rhdl/cli"

# =============================================================================
# Command Handlers using CLI Tasks
# =============================================================================

def show_help
  puts <<~HELP
    Usage: rhdl <command> [options]

    Commands:
      tui           Launch interactive TUI debugger
      diagram       Generate circuit diagrams
      export        Export components to Verilog
      gates         Gate-level synthesis
      apple2        Apple II emulator and ROM tools
      generate      Generate all output files (diagrams + HDL exports)
      clean         Clean all generated files
      regenerate    Clean and regenerate all output files

    Run 'rhdl <command> --help' for more information on a command.
  HELP
end

def handle_tui(args)
  options = {
    signals: :all,
    format: :auto,
    list: false,
    ink: false,
    install: false,
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl tui [options] <ComponentRef>

      Launch the interactive TUI debugger for HDL components.

      Examples:
        rhdl tui RHDL::HDL::Counter           # Ruby Curses TUI
        rhdl tui --ink sequential/counter     # Ink (React) TUI
        rhdl tui RHDL::HDL::ALU --signals inputs
        rhdl tui --list

      Ink TUI options:
        rhdl tui --ink [component]   Run with Ink (React-based) TUI
        rhdl tui --install           Install Ink TUI dependencies
        rhdl tui --clean             Clean Ink TUI build artifacts

      Keyboard Controls (in TUI):
        Space     Step one cycle
        n         Step half cycle
        r         Run simulation
        s         Stop/pause
        R         Reset simulation
        c         Continue until breakpoint
        w         Add watchpoint
        b         Add breakpoint
        j/k       Scroll signals
        :         Enter command mode
        h/?       Show help
        q         Quit

      Options:
    BANNER

    opts.on('--ink', 'Use Ink (React-based) TUI renderer') { options[:ink] = true }
    opts.on('--install', 'Install Ink TUI dependencies') { options[:install] = true }
    opts.on('--clean', 'Clean Ink TUI build artifacts') { options[:clean] = true }
    opts.on('--signals TYPE', 'Signals to display: all, inputs, outputs, or comma-separated list') do |v|
      options[:signals] = case v
                          when 'all' then :all
                          when 'inputs' then :inputs
                          when 'outputs' then :outputs
                          else v.split(',').map(&:strip).map(&:to_sym)
                          end
    end
    opts.on('--format FORMAT', 'Signal format: auto, binary, hex, decimal, signed') do |v|
      options[:format] = v.to_sym
    end
    opts.on('--list', 'List available components') { options[:list] = true }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift

  RHDL::CLI::Tasks::TuiTask.new(options).run
end

def handle_diagram(args)
  options = {
    level: 'component',
    depth: 1,
    format: 'svg',
    out: 'diagrams',
    bit_blasted: false,
    all: false,
    mode: nil,
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl diagram [options] [ComponentRef]

      Generate circuit diagrams for HDL components.

      Single component mode:
        rhdl diagram RHDL::HDL::ALU --level component --format svg

      Batch mode (generate all diagrams):
        rhdl diagram --all
        rhdl diagram --all --mode component
        rhdl diagram --all --mode hierarchical
        rhdl diagram --all --mode gate

      Options:
    BANNER

    opts.on('--all', 'Generate diagrams for all components') { options[:all] = true }
    opts.on('--mode MODE', 'Batch mode: component, hierarchical, gate, or all') { |v| options[:mode] = v }
    opts.on('--clean', 'Clean all generated diagrams') { options[:clean] = true }
    opts.on('--level LEVEL', 'Single component: component|hierarchy|netlist|gate') { |v| options[:level] = v }
    opts.on('--depth DEPTH', 'Depth for hierarchy (N or all)') do |v|
      options[:depth] = v == 'all' ? :all : v.to_i
    end
    opts.on('--bit-blasted', 'Bit-blast gate-level nets') { options[:bit_blasted] = true }
    opts.on('--format FORMAT', 'Output format: svg|png|dot') { |v| options[:format] = v }
    opts.on('--out DIR', 'Output directory') { |v| options[:out] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift unless options[:all] || options[:clean]

  RHDL::CLI::Tasks::DiagramTask.new(options).run
end

def handle_export(args)
  options = {
    lang: nil,
    out: nil,
    top: nil,
    all: false,
    scope: 'all',
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl export [options] [ComponentRef]

      Export HDL components to Verilog.

      Single component mode:
        rhdl export --lang verilog --out ./output RHDL::HDL::Counter

      Batch mode (export all components):
        rhdl export --all
        rhdl export --all --scope lib
        rhdl export --all --scope examples

      Options:
    BANNER

    opts.on('--all', 'Export all components') { options[:all] = true }
    opts.on('--scope SCOPE', 'Batch scope: all, lib, or examples') { |v| options[:scope] = v }
    opts.on('--clean', 'Clean all generated HDL files') { options[:clean] = true }
    opts.on('--lang LANG', 'Target language: verilog') { |v| options[:lang] = v }
    opts.on('--out DIR', 'Output directory') { |v| options[:out] = v }
    opts.on('--top NAME', 'Override top module/entity name') { |v| options[:top] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift unless options[:all] || options[:clean]

  RHDL::CLI::Tasks::ExportTask.new(options).run
end

def handle_gates(args)
  options = {
    export: false,
    simcpu: false,
    stats: false,
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl gates [options]

      Gate-level synthesis - export components to primitive gate netlists.

      Commands:
        rhdl gates --export    Export all components to JSON netlists
        rhdl gates --simcpu    Export SimCPU datapath components
        rhdl gates --stats     Show gate-level synthesis statistics
        rhdl gates --clean     Clean gate-level output

      Options:
    BANNER

    opts.on('--export', 'Export all components to gate-level IR (JSON netlists)') { options[:export] = true }
    opts.on('--simcpu', 'Export SimCPU datapath to gate-level') { options[:simcpu] = true }
    opts.on('--stats', 'Show gate-level synthesis statistics') { options[:stats] = true }
    opts.on('--clean', 'Clean gate-level synthesis output') { options[:clean] = true }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)

  # Default to export if no option specified
  options[:export] = true unless options.values.any?

  RHDL::CLI::Tasks::GatesTask.new(options).run
end

def handle_apple2(args)
  options = {
    build: false,
    run: false,
    demo: false,
    appleiigo: false,
    clean: false,
    debug: false,
    fast: false,
    rom: nil,
    rom_address: nil,
    address: nil,
    speed: nil,
    green: false,
    ink: false,
    hdl: false,
    hires: false,
    hires_width: nil,
    disk: nil,
    disk2: nil
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl apple2 [options] [FILE]

      Apple II emulator and ROM tools.

      Commands:
        rhdl apple2                Run the Apple II emulator (default)
        rhdl apple2 --build        Assemble the mini monitor ROM
        rhdl apple2 --demo         Run emulator in demo mode (no ROM needed)
        rhdl apple2 --appleiigo    Run with AppleIIGo public domain ROM
        rhdl apple2 --clean        Clean ROM output files

      Disk loading:
        rhdl apple2 --appleiigo --disk path/to/disk.dsk
        rhdl apple2 --rom ROM --disk disk1.dsk --disk2 disk2.dsk

      Hi-res graphics (for games like Karateka):
        rhdl apple2 --appleiigo --disk karateka.dsk --hires
        rhdl apple2 --appleiigo --disk karateka.dsk --hires --hires-width 140

      Ink TUI (React-based terminal UI):
        rhdl apple2 --ink          Run with Ink TUI (ISA mode, demo program)
        rhdl apple2 --ink --hdl    Run with Ink TUI (HDL mode)
        rhdl apple2 --ink FILE     Run program file with Ink TUI

      Options:
    BANNER

    opts.on('--build', 'Assemble the mini monitor ROM') { options[:build] = true }
    opts.on('--run', 'Run the emulator (after build)') { options[:run] = true }
    opts.on('--demo', 'Run emulator demo (no ROM needed)') { options[:demo] = true }
    opts.on('--appleiigo', 'Run with AppleIIGo public domain ROM') { options[:appleiigo] = true }
    opts.on('--clean', 'Clean ROM output files') { options[:clean] = true }
    opts.on('-d', '--debug', 'Enable debug mode') { options[:debug] = true }
    opts.on('-f', '--fast', 'Use fast ISA-level simulator (not cycle-accurate)') { options[:fast] = true }
    opts.on('-r', '--rom FILE', 'ROM file to load') { |v| options[:rom] = v }
    opts.on('-a', '--address ADDR', 'Program load address (hex, default: 0800)') { |v| options[:address] = v }
    opts.on('--rom-address ADDR', 'ROM load address (hex)') { |v| options[:rom_address] = v }
    opts.on('-s', '--speed CYCLES', Integer, 'Cycles per frame (default: 10000)') { |v| options[:speed] = v }
    opts.on('-g', '--green', 'Green phosphor screen effect') { options[:green] = true }
    opts.on('--ink', 'Use Ink (React-based) TUI renderer') { options[:ink] = true }
    opts.on('--hdl', 'Use HDL mode (cycle-accurate simulation)') { options[:hdl] = true }
    opts.on('-H', '--hires', 'Enable hi-res graphics rendering (uses braille characters)') { options[:hires] = true }
    opts.on('--hires-width WIDTH', Integer, 'Hi-res display width in chars (default: 80)') { |v| options[:hires_width] = v }
    opts.on('--disk FILE', 'Load disk image (.dsk) into drive 1') { |v| options[:disk] = v }
    opts.on('--disk2 FILE', 'Load disk image (.dsk) into drive 2') { |v| options[:disk2] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:program] = args.shift
  options[:remaining_args] = args

  RHDL::CLI::Tasks::Apple2Task.new(options).run
end

def handle_generate(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl generate [options]

      Generate all output files (diagrams + HDL exports).

      This is equivalent to running:
        rhdl diagram --all
        rhdl export --all

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :generate).run
end

def handle_clean(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl clean [options]

      Clean all generated files.

      This is equivalent to running:
        rhdl diagram --clean
        rhdl export --clean
        rhdl gates --clean

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :clean).run
end

def handle_regenerate(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl regenerate [options]

      Clean and regenerate all output files.

      This is equivalent to running:
        rhdl clean
        rhdl generate

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :regenerate).run
end

# =============================================================================
# Main Entry Point
# =============================================================================

command = ARGV.shift

case command
when 'tui'
  handle_tui(ARGV)
when 'diagram', 'diagrams'
  handle_diagram(ARGV)
when 'export', 'exports'
  handle_export(ARGV)
when 'gates', 'gate'
  handle_gates(ARGV)
when 'apple2'
  handle_apple2(ARGV)
when 'generate', 'generate_all'
  handle_generate(ARGV)
when 'clean', 'clean_all'
  handle_clean(ARGV)
when 'regenerate'
  handle_regenerate(ARGV)
when '-h', '--help', 'help', nil
  show_help
else
  warn "Unknown command: #{command}"
  warn ""
  show_help
  exit 1
end
