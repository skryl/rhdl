#!/usr/bin/env ruby
# frozen_string_literal: true

require "optparse"
require "rhdl"
require "rhdl/cli"

# =============================================================================
# Command Handlers using CLI Tasks
# =============================================================================

def show_help
  puts <<~HELP
    Usage: rhdl <command> [options]

    Commands:
      tui           Launch interactive TUI debugger
      diagram       Generate circuit diagrams
      export        Export components to Verilog
      gates         Gate-level synthesis
      apple2        Apple II emulator and ROM tools
      disk          Disk image utilities for Apple II
      generate      Generate all output files (diagrams + HDL exports)
      clean         Clean all generated files
      regenerate    Clean and regenerate all output files

    Run 'rhdl <command> --help' for more information on a command.
  HELP
end

def handle_tui(args)
  options = {
    signals: :all,
    format: :auto,
    list: false,
    ink: false,
    install: false,
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl tui [options] <ComponentRef>

      Launch the interactive TUI debugger for HDL components.

      Examples:
        rhdl tui RHDL::HDL::Counter           # Ruby Curses TUI
        rhdl tui --ink sequential/counter     # Ink (React) TUI
        rhdl tui RHDL::HDL::ALU --signals inputs
        rhdl tui --list

      Ink TUI options:
        rhdl tui --ink [component]   Run with Ink (React-based) TUI
        rhdl tui --install           Install Ink TUI dependencies
        rhdl tui --clean             Clean Ink TUI build artifacts

      Keyboard Controls (in TUI):
        Space     Step one cycle
        n         Step half cycle
        r         Run simulation
        s         Stop/pause
        R         Reset simulation
        c         Continue until breakpoint
        w         Add watchpoint
        b         Add breakpoint
        j/k       Scroll signals
        :         Enter command mode
        h/?       Show help
        q         Quit

      Options:
    BANNER

    opts.on('--ink', 'Use Ink (React-based) TUI renderer') { options[:ink] = true }
    opts.on('--install', 'Install Ink TUI dependencies') { options[:install] = true }
    opts.on('--clean', 'Clean Ink TUI build artifacts') { options[:clean] = true }
    opts.on('--signals TYPE', 'Signals to display: all, inputs, outputs, or comma-separated list') do |v|
      options[:signals] = case v
                          when 'all' then :all
                          when 'inputs' then :inputs
                          when 'outputs' then :outputs
                          else v.split(',').map(&:strip).map(&:to_sym)
                          end
    end
    opts.on('--format FORMAT', 'Signal format: auto, binary, hex, decimal, signed') do |v|
      options[:format] = v.to_sym
    end
    opts.on('--list', 'List available components') { options[:list] = true }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift

  RHDL::CLI::Tasks::TuiTask.new(options).run
end

def handle_diagram(args)
  options = {
    level: 'component',
    depth: 1,
    format: 'svg',
    out: 'diagrams',
    bit_blasted: false,
    all: false,
    mode: nil,
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl diagram [options] [ComponentRef]

      Generate circuit diagrams for HDL components.

      Single component mode:
        rhdl diagram RHDL::HDL::ALU --level component --format svg

      Batch mode (generate all diagrams):
        rhdl diagram --all
        rhdl diagram --all --mode component
        rhdl diagram --all --mode hierarchical
        rhdl diagram --all --mode gate

      Options:
    BANNER

    opts.on('--all', 'Generate diagrams for all components') { options[:all] = true }
    opts.on('--mode MODE', 'Batch mode: component, hierarchical, gate, or all') { |v| options[:mode] = v }
    opts.on('--clean', 'Clean all generated diagrams') { options[:clean] = true }
    opts.on('--level LEVEL', 'Single component: component|hierarchy|netlist|gate') { |v| options[:level] = v }
    opts.on('--depth DEPTH', 'Depth for hierarchy (N or all)') do |v|
      options[:depth] = v == 'all' ? :all : v.to_i
    end
    opts.on('--bit-blasted', 'Bit-blast gate-level nets') { options[:bit_blasted] = true }
    opts.on('--format FORMAT', 'Output format: svg|png|dot') { |v| options[:format] = v }
    opts.on('--out DIR', 'Output directory') { |v| options[:out] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift unless options[:all] || options[:clean]

  RHDL::CLI::Tasks::DiagramTask.new(options).run
end

def handle_export(args)
  options = {
    lang: nil,
    out: nil,
    top: nil,
    all: false,
    scope: 'all',
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl export [options] [ComponentRef]

      Export HDL components to Verilog.

      Single component mode:
        rhdl export --lang verilog --out ./output RHDL::HDL::Counter

      Batch mode (export all components):
        rhdl export --all
        rhdl export --all --scope lib
        rhdl export --all --scope examples

      Options:
    BANNER

    opts.on('--all', 'Export all components') { options[:all] = true }
    opts.on('--scope SCOPE', 'Batch scope: all, lib, or examples') { |v| options[:scope] = v }
    opts.on('--clean', 'Clean all generated HDL files') { options[:clean] = true }
    opts.on('--lang LANG', 'Target language: verilog') { |v| options[:lang] = v }
    opts.on('--out DIR', 'Output directory') { |v| options[:out] = v }
    opts.on('--top NAME', 'Override top module/entity name') { |v| options[:top] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift unless options[:all] || options[:clean]

  RHDL::CLI::Tasks::ExportTask.new(options).run
end

def handle_gates(args)
  options = {
    export: false,
    simcpu: false,
    stats: false,
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl gates [options]

      Gate-level synthesis - export components to primitive gate netlists.

      Commands:
        rhdl gates --export    Export all components to JSON netlists
        rhdl gates --simcpu    Export SimCPU datapath components
        rhdl gates --stats     Show gate-level synthesis statistics
        rhdl gates --clean     Clean gate-level output

      Options:
    BANNER

    opts.on('--export', 'Export all components to gate-level IR (JSON netlists)') { options[:export] = true }
    opts.on('--simcpu', 'Export SimCPU datapath to gate-level') { options[:simcpu] = true }
    opts.on('--stats', 'Show gate-level synthesis statistics') { options[:stats] = true }
    opts.on('--clean', 'Clean gate-level synthesis output') { options[:clean] = true }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)

  # Default to export if no option specified
  options[:export] = true unless options.values.any?

  RHDL::CLI::Tasks::GatesTask.new(options).run
end

def handle_disk(args)
  options = {
    info: false,
    convert: false,
    extract_boot: false,
    extract_tracks: false,
    dump_after_boot: false,
    disk: nil,
    output: nil,
    rom: nil,
    start_track: nil,
    end_track: nil,
    prodos: false,
    max_cycles: nil,
    base_addr: nil,
    end_addr: nil
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl disk <command> [options] FILE

      Disk image utilities for Apple II.

      Commands:
        rhdl disk info FILE            Show disk image information
        rhdl disk convert FILE         Convert disk to binary file
        rhdl disk boot FILE            Extract boot sector
        rhdl disk tracks FILE          Extract specific tracks
        rhdl disk memdump FILE         Boot disk and dump memory (requires ROM)

      Options:
    BANNER

    opts.on('-o', '--output FILE', 'Output file path') { |v| options[:output] = v }
    opts.on('-r', '--rom FILE', 'ROM file for booting (memdump only)') { |v| options[:rom] = v }
    opts.on('--start-track N', Integer, 'Start track for extraction') { |v| options[:start_track] = v }
    opts.on('--end-track N', Integer, 'End track for extraction') { |v| options[:end_track] = v }
    opts.on('--prodos', 'Use ProDOS sector interleaving') { options[:prodos] = true }
    opts.on('--max-cycles N', Integer, 'Max boot cycles for memdump') { |v| options[:max_cycles] = v }
    opts.on('--base-addr ADDR', 'Memory dump base address (hex)') { |v| options[:base_addr] = v.to_i(16) }
    opts.on('--end-addr ADDR', 'Memory dump end address (hex)') { |v| options[:end_addr] = v.to_i(16) }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)

  command = args.shift
  options[:disk] = args.shift

  case command
  when 'info'
    options[:info] = true
  when 'convert'
    options[:convert] = true
  when 'boot'
    options[:extract_boot] = true
  when 'tracks'
    options[:extract_tracks] = true
  when 'memdump'
    options[:dump_after_boot] = true
  when nil, '-h', '--help', 'help'
    puts parser
    exit 0
  else
    warn "Unknown disk command: #{command}"
    puts parser
    exit 1
  end

  unless options[:disk]
    warn "Error: No disk file specified"
    puts parser
    exit 1
  end

  RHDL::CLI::Tasks::DiskConvertTask.new(options).run
end

def handle_apple2(args)
  options = {
    build: false,
    run: false,
    demo: false,
    appleiigo: false,
    karateka: false,
    clean: false,
    debug: false,
    mode: :native,  # Simulator mode: native, ruby, or hdl
    rom: nil,
    rom_address: nil,
    address: nil,
    speed: nil,
    green: false,
    ink: false,
    hires: false,
    hires_width: nil,
    disk: nil,
    disk2: nil
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl apple2 [options] [FILE]

      Apple II emulator and ROM tools.

      Commands:
        rhdl apple2                Run the Apple II emulator (default)
        rhdl apple2 --build        Assemble the mini monitor ROM
        rhdl apple2 --demo         Run emulator in demo mode (no ROM needed)
        rhdl apple2 --appleiigo    Run with AppleIIGo public domain ROM
        rhdl apple2 --clean        Clean ROM output files

      Disk loading:
        rhdl apple2 --appleiigo --disk path/to/disk.dsk
        rhdl apple2 --rom ROM --disk disk1.dsk --disk2 disk2.dsk

      Hi-res graphics (for games like Karateka):
        rhdl apple2 --appleiigo --disk karateka.dsk --hires
        rhdl apple2 --appleiigo --disk karateka.dsk --hires --hires-width 140

      Quick start (pre-loaded memory dump):
        rhdl apple2 --karateka     Run Karateka directly (no disk/ROM needed)

      Ink TUI (React-based terminal UI):
        rhdl apple2 --ink          Run with Ink TUI (ISA mode, demo program)
        rhdl apple2 --ink --hdl    Run with Ink TUI (HDL mode)
        rhdl apple2 --ink FILE     Run program file with Ink TUI

      Options:
    BANNER

    opts.on('--build', 'Assemble the mini monitor ROM') { options[:build] = true }
    opts.on('--run', 'Run the emulator (after build)') { options[:run] = true }
    opts.on('--demo', 'Run emulator demo (no ROM needed)') { options[:demo] = true }
    opts.on('--appleiigo', 'Run with AppleIIGo public domain ROM') { options[:appleiigo] = true }
    opts.on('-k', '--karateka', 'Load Karateka memory dump (ready to play)') { options[:karateka] = true }
    opts.on('--clean', 'Clean ROM output files') { options[:clean] = true }
    opts.on('-d', '--debug', 'Enable debug mode') { options[:debug] = true }
    opts.on('-m', '--mode TYPE', [:native, :ruby, :hdl], 'Simulator mode: native (default), ruby, hdl') { |v| options[:mode] = v }
    opts.on('-r', '--rom FILE', 'ROM file to load') { |v| options[:rom] = v }
    opts.on('-a', '--address ADDR', 'Program load address (hex, default: 0800)') { |v| options[:address] = v }
    opts.on('--rom-address ADDR', 'ROM load address (hex)') { |v| options[:rom_address] = v }
    opts.on('-s', '--speed CYCLES', Integer, 'Cycles per frame (default: 10000)') { |v| options[:speed] = v }
    opts.on('-g', '--green', 'Green phosphor screen effect') { options[:green] = true }
    opts.on('--ink', 'Use Ink (React-based) TUI renderer') { options[:ink] = true }
    opts.on('-H', '--hires', 'Enable hi-res graphics rendering (uses braille characters)') { options[:hires] = true }
    opts.on('--hires-width WIDTH', Integer, 'Hi-res display width in chars (default: 80)') { |v| options[:hires_width] = v }
    opts.on('--disk FILE', 'Load disk image (.dsk) into drive 1') { |v| options[:disk] = v }
    opts.on('--disk2 FILE', 'Load disk image (.dsk) into drive 2') { |v| options[:disk2] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:program] = args.shift
  options[:remaining_args] = args

  RHDL::CLI::Tasks::Apple2Task.new(options).run
end

def handle_generate(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl generate [options]

      Generate all output files (diagrams + HDL exports).

      This is equivalent to running:
        rhdl diagram --all
        rhdl export --all

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :generate).run
end

def handle_clean(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl clean [options]

      Clean all generated files.

      This is equivalent to running:
        rhdl diagram --clean
        rhdl export --clean
        rhdl gates --clean

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :clean).run
end

def handle_regenerate(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl regenerate [options]

      Clean and regenerate all output files.

      This is equivalent to running:
        rhdl clean
        rhdl generate

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :regenerate).run
end

# =============================================================================
# Main Entry Point
# =============================================================================

command = ARGV.shift

case command
when 'tui'
  handle_tui(ARGV)
when 'diagram', 'diagrams'
  handle_diagram(ARGV)
when 'export', 'exports'
  handle_export(ARGV)
when 'gates', 'gate'
  handle_gates(ARGV)
when 'apple2'
  handle_apple2(ARGV)
when 'disk'
  handle_disk(ARGV)
when 'generate', 'generate_all'
  handle_generate(ARGV)
when 'clean', 'clean_all'
  handle_clean(ARGV)
when 'regenerate'
  handle_regenerate(ARGV)
when '-h', '--help', 'help', nil
  show_help
else
  warn "Unknown command: #{command}"
  warn ""
  show_help
  exit 1
end
