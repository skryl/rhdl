#!/usr/bin/env ruby
# frozen_string_literal: true

require "optparse"
require "rhdl"
require "rhdl/cli"

# =============================================================================
# Command Handlers using CLI Tasks
# =============================================================================

def show_help
  puts <<~HELP
    Usage: rhdl <command> [options]

    Commands:
      tui           Launch interactive TUI debugger
      diagram       Generate circuit diagrams
      export        Export components to Verilog
      gates         Gate-level synthesis
      examples      Run example emulators (mos6502, apple2)
      disk          Disk image utilities for Apple II
      generate      Generate all output files (diagrams + HDL exports)
      clean         Clean all generated files
      regenerate    Clean and regenerate all output files

    Run 'rhdl <command> --help' for more information on a command.
  HELP
end

def handle_tui(args)
  options = {
    signals: :all,
    format: :auto,
    list: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl tui [options] <ComponentRef>

      Launch the interactive TUI debugger for HDL components.

      Examples:
        rhdl tui RHDL::HDL::Counter
        rhdl tui sequential/counter
        rhdl tui RHDL::HDL::ALU --signals inputs
        rhdl tui --list

      Keyboard Controls (in TUI):
        Space     Step one cycle
        n         Step half cycle
        r         Run simulation
        s         Stop/pause
        R         Reset simulation
        c         Continue until breakpoint
        w         Add watchpoint
        b         Add breakpoint
        j/k       Scroll signals
        :         Enter command mode
        h/?       Show help
        q         Quit

      Options:
    BANNER

    opts.on('--signals TYPE', 'Signals to display: all, inputs, outputs, or comma-separated list') do |v|
      options[:signals] = case v
                          when 'all' then :all
                          when 'inputs' then :inputs
                          when 'outputs' then :outputs
                          else v.split(',').map(&:strip).map(&:to_sym)
                          end
    end
    opts.on('--format FORMAT', 'Signal format: auto, binary, hex, decimal, signed') do |v|
      options[:format] = v.to_sym
    end
    opts.on('--list', 'List available components') { options[:list] = true }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift

  RHDL::CLI::Tasks::TuiTask.new(options).run
end

def handle_diagram(args)
  options = {
    level: 'component',
    depth: 1,
    format: 'svg',
    out: 'diagrams',
    bit_blasted: false,
    all: false,
    mode: nil,
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl diagram [options] [ComponentRef]

      Generate circuit diagrams for HDL components.

      Single component mode:
        rhdl diagram RHDL::HDL::ALU --level component --format svg

      Batch mode (generate all diagrams):
        rhdl diagram --all
        rhdl diagram --all --mode component
        rhdl diagram --all --mode hierarchical
        rhdl diagram --all --mode gate

      Options:
    BANNER

    opts.on('--all', 'Generate diagrams for all components') { options[:all] = true }
    opts.on('--mode MODE', 'Batch mode: component, hierarchical, gate, or all') { |v| options[:mode] = v }
    opts.on('--clean', 'Clean all generated diagrams') { options[:clean] = true }
    opts.on('--level LEVEL', 'Single component: component|hierarchy|netlist|gate') { |v| options[:level] = v }
    opts.on('--depth DEPTH', 'Depth for hierarchy (N or all)') do |v|
      options[:depth] = v == 'all' ? :all : v.to_i
    end
    opts.on('--bit-blasted', 'Bit-blast gate-level nets') { options[:bit_blasted] = true }
    opts.on('--format FORMAT', 'Output format: svg|png|dot') { |v| options[:format] = v }
    opts.on('--out DIR', 'Output directory') { |v| options[:out] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift unless options[:all] || options[:clean]

  RHDL::CLI::Tasks::DiagramTask.new(options).run
end

def handle_export(args)
  options = {
    lang: nil,
    out: nil,
    top: nil,
    all: false,
    scope: 'all',
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl export [options] [ComponentRef]

      Export HDL components to Verilog.

      Single component mode:
        rhdl export --lang verilog --out ./output RHDL::HDL::Counter

      Batch mode (export all components):
        rhdl export --all
        rhdl export --all --scope lib
        rhdl export --all --scope examples

      Options:
    BANNER

    opts.on('--all', 'Export all components') { options[:all] = true }
    opts.on('--scope SCOPE', 'Batch scope: all, lib, or examples') { |v| options[:scope] = v }
    opts.on('--clean', 'Clean all generated HDL files') { options[:clean] = true }
    opts.on('--lang LANG', 'Target language: verilog') { |v| options[:lang] = v }
    opts.on('--out DIR', 'Output directory') { |v| options[:out] = v }
    opts.on('--top NAME', 'Override top module/entity name') { |v| options[:top] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:component] = args.shift unless options[:all] || options[:clean]

  RHDL::CLI::Tasks::ExportTask.new(options).run
end

def handle_gates(args)
  options = {
    export: false,
    simcpu: false,
    stats: false,
    clean: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl gates [options]

      Gate-level synthesis - export components to primitive gate netlists.

      Commands:
        rhdl gates --export    Export all components to JSON netlists
        rhdl gates --simcpu    Export SimCPU datapath components
        rhdl gates --stats     Show gate-level synthesis statistics
        rhdl gates --clean     Clean gate-level output

      Options:
    BANNER

    opts.on('--export', 'Export all components to gate-level IR (JSON netlists)') { options[:export] = true }
    opts.on('--simcpu', 'Export SimCPU datapath to gate-level') { options[:simcpu] = true }
    opts.on('--stats', 'Show gate-level synthesis statistics') { options[:stats] = true }
    opts.on('--clean', 'Clean gate-level synthesis output') { options[:clean] = true }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)

  # Default to export if no option specified
  options[:export] = true unless options.values.any?

  RHDL::CLI::Tasks::GatesTask.new(options).run
end

def handle_disk(args)
  options = {
    info: false,
    convert: false,
    extract_boot: false,
    extract_tracks: false,
    dump_after_boot: false,
    disk: nil,
    output: nil,
    rom: nil,
    start_track: nil,
    end_track: nil,
    prodos: false,
    max_cycles: nil,
    base_addr: nil,
    end_addr: nil
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl disk <command> [options] FILE

      Disk image utilities for Apple II.

      Commands:
        rhdl disk info FILE            Show disk image information
        rhdl disk convert FILE         Convert disk to binary file
        rhdl disk boot FILE            Extract boot sector
        rhdl disk tracks FILE          Extract specific tracks
        rhdl disk memdump FILE         Boot disk and dump memory (requires ROM)

      Options:
    BANNER

    opts.on('-o', '--output FILE', 'Output file path') { |v| options[:output] = v }
    opts.on('-r', '--rom FILE', 'ROM file for booting (memdump only)') { |v| options[:rom] = v }
    opts.on('--start-track N', Integer, 'Start track for extraction') { |v| options[:start_track] = v }
    opts.on('--end-track N', Integer, 'End track for extraction') { |v| options[:end_track] = v }
    opts.on('--prodos', 'Use ProDOS sector interleaving') { options[:prodos] = true }
    opts.on('--max-cycles N', Integer, 'Max boot cycles for memdump') { |v| options[:max_cycles] = v }
    opts.on('--base-addr ADDR', 'Memory dump base address (hex)') { |v| options[:base_addr] = v.to_i(16) }
    opts.on('--end-addr ADDR', 'Memory dump end address (hex)') { |v| options[:end_addr] = v.to_i(16) }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)

  command = args.shift
  options[:disk] = args.shift

  case command
  when 'info'
    options[:info] = true
  when 'convert'
    options[:convert] = true
  when 'boot'
    options[:extract_boot] = true
  when 'tracks'
    options[:extract_tracks] = true
  when 'memdump'
    options[:dump_after_boot] = true
  when nil, '-h', '--help', 'help'
    puts parser
    exit 0
  else
    warn "Unknown disk command: #{command}"
    puts parser
    exit 1
  end

  unless options[:disk]
    warn "Error: No disk file specified"
    puts parser
    exit 1
  end

  RHDL::CLI::Tasks::DiskConvertTask.new(options).run
end

def show_examples_help
  puts <<~HELP
    Usage: rhdl examples <subcommand> [options]

    Run example emulators.

    Subcommands:
      mos6502       MOS 6502 ISA emulator (fast, behavioral simulation)
      apple2        Apple II HDL emulator (cycle-accurate, supports netlist mode)

    Examples:
      rhdl examples mos6502 --demo
      rhdl examples mos6502 --appleiigo --disk game.dsk
      rhdl examples apple2 --demo
      rhdl examples apple2 --mode netlist --sim jit --demo

    Run 'rhdl examples <subcommand> --help' for more information.
  HELP
end

def handle_examples_mos6502(args)
  options = {
    build: false,
    run: false,
    demo: false,
    appleiigo: false,
    karateka: false,
    clean: false,
    debug: false,
    mode: :isa,       # Simulator mode: isa, hdl, or netlist
    sim: :jit,        # Sim backend: interpret, jit, or compile (ignored for ISA mode)
    rom: nil,
    rom_address: nil,
    address: nil,
    speed: nil,
    green: false,
    hires: false,
    hires_width: nil,
    disk: nil,
    disk2: nil
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl examples mos6502 [options] [FILE]

      MOS 6502 emulator with multiple simulation backends.

      Commands:
        rhdl examples mos6502                Run the emulator (default)
        rhdl examples mos6502 --build        Assemble the mini monitor ROM
        rhdl examples mos6502 --demo         Run emulator in demo mode
        rhdl examples mos6502 --appleiigo    Run with AppleIIGo ROM
        rhdl examples mos6502 --clean        Clean ROM output files

      Simulation modes:
        --mode isa              ISA-level simulation (default, fastest)
        --mode hdl              HDL behavioral simulation (cycle-accurate)
        --mode netlist          Gate-level netlist simulation (slowest)

      Simulator backends (for HDL/netlist modes):
        --sim interpret         Pure interpreter (slow, fast startup)
        --sim jit               Cranelift JIT (default, balanced)
        --sim compile           AOT compiled (fastest, slow startup)

      Examples:
        rhdl examples mos6502 --karateka
        rhdl examples mos6502 --mode hdl --sim compile --karateka
        rhdl examples mos6502 --appleiigo --disk game.dsk --hires

      Options:
    BANNER

    opts.on('--build', 'Assemble the mini monitor ROM') { options[:build] = true }
    opts.on('--run', 'Run the emulator (after build)') { options[:run] = true }
    opts.on('--demo', 'Run emulator demo (no ROM needed)') { options[:demo] = true }
    opts.on('--appleiigo', 'Run with AppleIIGo public domain ROM') { options[:appleiigo] = true }
    opts.on('-k', '--karateka', 'Load Karateka memory dump (ready to play)') { options[:karateka] = true }
    opts.on('--clean', 'Clean ROM output files') { options[:clean] = true }
    opts.on('-d', '--debug', 'Enable debug mode') { options[:debug] = true }
    opts.on('-m', '--mode TYPE', [:isa, :hdl, :netlist], 'Simulator mode: isa (default), hdl, netlist') { |v| options[:mode] = v }
    opts.on('--sim TYPE', [:interpret, :jit, :compile], 'Sim backend: interpret, jit (default), compile') { |v| options[:sim] = v }
    opts.on('-r', '--rom FILE', 'ROM file to load') { |v| options[:rom] = v }
    opts.on('-a', '--address ADDR', 'Program load address (hex, default: 0800)') { |v| options[:address] = v }
    opts.on('--rom-address ADDR', 'ROM load address (hex)') { |v| options[:rom_address] = v }
    opts.on('-s', '--speed CYCLES', Integer, 'Cycles per frame') { |v| options[:speed] = v }
    opts.on('-g', '--green', 'Green phosphor screen effect') { options[:green] = true }
    opts.on('-H', '--hires', 'Enable hi-res graphics rendering') { options[:hires] = true }
    opts.on('--hires-width WIDTH', Integer, 'Hi-res display width in chars (default: 80)') { |v| options[:hires_width] = v }
    opts.on('--disk FILE', 'Load disk image (.dsk) into drive 1') { |v| options[:disk] = v }
    opts.on('--disk2 FILE', 'Load disk image (.dsk) into drive 2') { |v| options[:disk2] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:program] = args.shift
  options[:remaining_args] = args

  RHDL::CLI::Tasks::MOS6502Task.new(options).run
end

def handle_examples_apple2(args)
  options = {
    demo: false,
    appleiigo: false,
    karateka: false,
    debug: false,
    mode: :hdl,       # Simulation mode: hdl (default), netlist
    sim: :ruby,       # Simulator backend: ruby (default), interpret, jit, compile
    rom: nil,
    address: nil,
    speed: nil,
    green: false,
    hires: false,
    hires_width: nil,
    disk: nil
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl examples apple2 [options] [FILE]

      Apple II HDL emulator - cycle-accurate simulation with netlist support.

      Commands:
        rhdl examples apple2                Run the emulator (default)
        rhdl examples apple2 --demo         Run emulator in demo mode
        rhdl examples apple2 --appleiigo    Run with AppleIIGo ROM
        rhdl examples apple2 --karateka     Run Karateka directly

      Simulation modes:
        --mode hdl                HDL behavioral simulation (default)
        --mode netlist            Gate-level netlist simulation

      Simulator backends:
        --sim ruby                Pure Ruby interpreter (default)
        --sim interpret           Rust interpreter (fast startup)
        --sim jit                 Cranelift JIT (balanced)
        --sim compile             AOT compiled (fastest, slow startup)

      Examples:
        rhdl examples apple2 --demo
        rhdl examples apple2 --mode netlist --sim jit --demo
        rhdl examples apple2 --mode netlist --sim compile --karateka

      Options:
    BANNER

    opts.on('--demo', 'Run emulator demo (no ROM needed)') { options[:demo] = true }
    opts.on('--appleiigo', 'Run with AppleIIGo public domain ROM') { options[:appleiigo] = true }
    opts.on('-k', '--karateka', 'Load Karateka memory dump (ready to play)') { options[:karateka] = true }
    opts.on('-d', '--debug', 'Enable debug mode') { options[:debug] = true }
    opts.on('-m', '--mode TYPE', [:hdl, :netlist], 'Simulation mode: hdl (default), netlist') { |v| options[:mode] = v }
    opts.on('--sim TYPE', [:ruby, :interpret, :jit, :compile], 'Simulator backend: ruby (default), interpret, jit, compile') { |v| options[:sim] = v }
    opts.on('-r', '--rom FILE', 'ROM file to load') { |v| options[:rom] = v }
    opts.on('-a', '--address ADDR', 'Program load address (hex, default: 0800)') { |v| options[:address] = v }
    opts.on('-s', '--speed CYCLES', Integer, 'Cycles per frame (default: 100)') { |v| options[:speed] = v }
    opts.on('-g', '--green', 'Green phosphor screen effect') { options[:green] = true }
    opts.on('-H', '--hires', 'Enable hi-res graphics rendering') { options[:hires] = true }
    opts.on('--hires-width WIDTH', Integer, 'Hi-res display width in chars (default: 80)') { |v| options[:hires_width] = v }
    opts.on('--disk FILE', 'Load disk image (.dsk)') { |v| options[:disk] = v }
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  options[:program] = args.shift
  options[:remaining_args] = args

  RHDL::CLI::Tasks::Apple2Task.new(options).run
end

def handle_examples(args)
  subcommand = args.shift

  case subcommand
  when 'mos6502'
    handle_examples_mos6502(args)
  when 'apple2'
    handle_examples_apple2(args)
  when '-h', '--help', 'help', nil
    show_examples_help
    exit 0
  else
    warn "Unknown examples subcommand: #{subcommand}"
    warn ""
    show_examples_help
    exit 1
  end
end

def handle_generate(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl generate [options]

      Generate all output files (diagrams + HDL exports).

      This is equivalent to running:
        rhdl diagram --all
        rhdl export --all

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :generate).run
end

def handle_clean(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl clean [options]

      Clean all generated files.

      This is equivalent to running:
        rhdl diagram --clean
        rhdl export --clean
        rhdl gates --clean

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :clean).run
end

def handle_regenerate(args)
  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: rhdl regenerate [options]

      Clean and regenerate all output files.

      This is equivalent to running:
        rhdl clean
        rhdl generate

      Options:
    BANNER

    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  parser.parse!(args)
  RHDL::CLI::Tasks::GenerateTask.new(action: :regenerate).run
end

# =============================================================================
# Main Entry Point
# =============================================================================

command = ARGV.shift

case command
when 'tui'
  handle_tui(ARGV)
when 'diagram', 'diagrams'
  handle_diagram(ARGV)
when 'export', 'exports'
  handle_export(ARGV)
when 'gates', 'gate'
  handle_gates(ARGV)
when 'examples'
  handle_examples(ARGV)
when 'disk'
  handle_disk(ARGV)
when 'generate', 'generate_all'
  handle_generate(ARGV)
when 'clean', 'clean_all'
  handle_clean(ARGV)
when 'regenerate'
  handle_regenerate(ARGV)
when '-h', '--help', 'help', nil
  show_help
else
  warn "Unknown command: #{command}"
  warn ""
  show_help
  exit 1
end
