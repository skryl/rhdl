use std::env;
use std::fs;
use std::path::PathBuf;

use ir_compiler::{Apple2Extension, CoreSimulator, GameBoyExtension, Mos6502Extension};

fn usage(program: &str) -> String {
    format!(
        "Usage: {program} <ir_json_path> [out_rs_path]\n\
         Example: {program} /path/to/repo/web/samples/apple2.json src/aot_generated.rs"
    )
}

fn append_missing_stubs(code: &mut String, has_apple2: bool, has_gameboy: bool, has_mos6502: bool) {
    if !has_apple2 {
        code.push_str(
            r#"
#[no_mangle]
pub unsafe extern "C" fn run_cpu_cycles(
    _signals: *mut u64,
    _signals_len: usize,
    _ram: *mut u8,
    _ram_len: usize,
    _rom: *const u8,
    _rom_len: usize,
    _n: usize,
    _key_data: u8,
    _key_ready: bool,
    _prev_speaker_ptr: *mut u64,
    text_dirty_out: *mut bool,
    key_cleared_out: *mut bool,
    speaker_toggles_out: *mut u32,
) -> usize {
    if !text_dirty_out.is_null() { *text_dirty_out = false; }
    if !key_cleared_out.is_null() { *key_cleared_out = false; }
    if !speaker_toggles_out.is_null() { *speaker_toggles_out = 0; }
    0
}
"#,
        );
    }

    if !has_gameboy {
        code.push_str(
            r#"
#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct GbLcdState {
    pub x: u32,
    pub y: u32,
    pub prev_clkena: u32,
    pub prev_vsync: u32,
    pub frame_count: u64,
}

#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct GbCycleResult {
    pub cycles_run: usize,
    pub frames_completed: u32,
}

#[no_mangle]
pub unsafe extern "C" fn run_gb_cycles(
    _signals: *mut u64,
    _signals_len: usize,
    _n: usize,
    _old_clocks: *mut u64,
    _next_regs: *mut u64,
    _framebuffer: *mut u8,
    _lcd_state: *mut GbLcdState,
    _rom: *const u8,
    _rom_len: usize,
    _vram: *mut u8,
    _vram_len: usize,
    _boot_rom: *const u8,
    _boot_rom_len: usize,
    _zpram: *mut u8,
    _zpram_len: usize,
    _wram: *mut u8,
    _wram_len: usize,
) -> GbCycleResult {
    GbCycleResult::default()
}
"#,
        );
    }

    if !has_mos6502 {
        code.push_str(
            r#"
#[no_mangle]
pub unsafe extern "C" fn run_mos6502_cycles(
    _signals: *mut u64,
    _signals_len: usize,
    _memory: *mut u8,
    _rom_mask: *const bool,
    _n: usize,
    speaker_toggles_out: *mut u32,
) -> usize {
    if !speaker_toggles_out.is_null() { *speaker_toggles_out = 0; }
    0
}

#[no_mangle]
pub unsafe extern "C" fn run_mos6502_instructions_with_opcodes(
    _signals: *mut u64,
    _signals_len: usize,
    _memory: *mut u8,
    _rom_mask: *const bool,
    _n: usize,
    _opcodes_out: *mut u64,
    _opcodes_capacity: usize,
    speaker_toggles_out: *mut u32,
) -> usize {
    if !speaker_toggles_out.is_null() { *speaker_toggles_out = 0; }
    0
}
"#,
        );
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut args = env::args();
    let program = args.next().unwrap_or_else(|| "aot_codegen".to_string());
    let ir_path = match args.next() {
        Some(path) => PathBuf::from(path),
        None => return Err(usage(&program).into()),
    };
    let out_path = PathBuf::from(
        args.next()
            .unwrap_or_else(|| "src/aot_generated.rs".to_string()),
    );

    let ir_json = fs::read_to_string(&ir_path)?;
    let core = CoreSimulator::new(&ir_json)
        .map_err(|e| format!("Failed to parse IR JSON {}: {}", ir_path.display(), e))?;

    let has_apple2 = Apple2Extension::is_apple2_ir(&core.name_to_idx);
    let has_gameboy = GameBoyExtension::is_gameboy_ir(&core.name_to_idx);
    let has_mos6502 = Mos6502Extension::is_mos6502_ir(&core.name_to_idx);

    let mut code = String::new();
    code.push_str("// @generated by ir_compiler/src/bin/aot_codegen.rs. DO NOT EDIT.\n");
    code.push_str("#![allow(dead_code)]\n");
    code.push_str("#![allow(unused_variables)]\n");
    code.push_str("#![allow(unused_mut)]\n\n");
    code.push_str("#![allow(unused_parens)]\n\n");
    code.push_str(&core.generate_core_code());

    if has_apple2 {
        code.push_str(&Apple2Extension::generate_code(&core));
    }
    if has_gameboy {
        code.push_str(&GameBoyExtension::generate_code(&core));
    }
    if has_mos6502 {
        code.push_str(&Mos6502Extension::generate_code(&core));
        code.push_str(&Mos6502Extension::generate_code_run_instructions_with_opcodes(
            &core,
        ));
    }

    append_missing_stubs(&mut code, has_apple2, has_gameboy, has_mos6502);
    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(&out_path, code)?;

    println!(
        "Generated AOT source from {} -> {} (apple2={}, gameboy={}, mos6502={})",
        ir_path.display(),
        out_path.display(),
        has_apple2,
        has_gameboy,
        has_mos6502
    );
    Ok(())
}
